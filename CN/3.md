# 3 OpenMAX 集成层控制 API（OpenMAX Integration Layer Control API）
OpenMAX 集成层 API（OpenMAX Integration Layer API，以下简称 OpenMAX IL API）支持集成层客户端（integration layer client）对音频、视频和图像领域的多媒体组件（multimedia component）进行控制。该 API 还包含一个“其他领域”（other domain），用于提供额外功能，例如音视频（A/V）同步。OpenMAX IL API 的使用者通常是多媒体框架（multimedia framework）。在本文档的后续内容中，OpenMAX IL API 的使用者将被称为 **IL 客户端**（IL client）。

OpenMAX IL API 定义在一组头文件中，具体如下：
- **OMX_Types.h**：OpenMAX IL 中使用的数据类型（Data types）
- **OMX_Core.h**：OpenMAX IL 核心 API（core API）
- **OMX_Component.h**：OpenMAX IL 组件 API（component API）
- **OMX_Audio.h**：OpenMAX IL 音频领域数据结构（audio domain data structures）
- **OMX_IVCommon.h**：OpenMAX IL 图像与视频领域通用数据结构（structures common to image and video domains）
- **OMX_Video.h**：OpenMAX IL 视频领域数据结构（video domain data structures）
- **OMX_Image.h**：OpenMAX IL 图像领域数据结构（image domain data structures）
- **OMX_Other.h**：OpenMAX IL 其他领域数据结构（other domain data structures，包含音视频同步功能）
- **OMX_Index.h**：所有 OpenMAX IL 定义的数据结构的索引（Index of all OpenMAX IL-defined data structures）
- **OMX_ContentPipe.h**：内容管道（Content Pipe）的定义

本节将介绍如何配置 OpenMAX IL 核心（IL core）和 OpenMAX IL 组件（IL components）以实现正常运行，具体流程如下：
1. 首先介绍 OpenMAX IL 的数据类型（Data types）；
2. 其次描述 OpenMAX IL 核心的方法（methods）；
3. 组件实现的方法将在 3.2.3 节中讨论；
4. 最后，3.4 节将展示若干关键操作的调用序列（calling sequences），包括组件初始化（component initialization）、正常数据流（normal data flow）、数据隧道设置（data tunnel setup）以及存在数据隧道时的数据流（data flow in the presence of data tunneling）。这些序列图旨在描述 IL 客户端、IL 核心与 OpenMAX IL 组件之间的动态交互过程。

在对函数（functions）进行文档说明时，函数参数（function parameters）采用以下约定：
- `<param_name> [in]`：表示输入参数（input parameter），由函数调用者（function caller）设置，供函数实现（function implementation）读取；
- `<param_name> [out]`：表示输出参数（output parameter），由函数实现设置，并返回给调用者。函数返回后，调用者可读取该参数的新值（参数以引用形式传递）；
- `<param_name> [inout]`：表示输入输出参数（input/output parameter），函数调用者可对其进行设置，函数实现可在将其返回给调用者前修改该参数的值。

此参数分类也可在 OpenMAX IL 头文件中找到，这些头文件定义了空宏（null macros）**OMX_IN**、**OMX_OUT** 和 **OMX_INOUT**，对应关系如下：
- OMX_IN 对应函数参数 `<param_name> [in]`；
- OMX_OUT 对应函数参数 `<param_name> [out]`；
- OMX_INOUT 对应函数参数 `<param_name> [inout]`。


## 3.1 OpenMAX IL 类型（OpenMAX IL Types）
### 3.1.1 枚举类型（Enumerations）
**OMX_Core.h** 中定义了 5 种 32 位整数枚举类型（32-bit integer enumerations），具体如下：
- **OMX_ERRORTYPE**：由 OpenMAX IL API 中定义的每个函数返回（详见 3.1.1.3 节）；
- **OMX_COMMANDTYPE**：包含 IL 客户端可发送给 OpenMAX IL 组件的所有可能命令（详见 3.1.1.1 节）；
- **OMX_EVENTTYPE**：包含 OpenMAX IL 组件内部可生成的所有事件（events），这些事件通过回调函数（callback function）传递给 IL 客户端（详见 3.1.1.4 节）；
- **OMX_BUFFERSUPPLIERTYPE**：包含隧道端口（tunneled ports）场景下缓冲区提供者（buffer supplier）的所有可能类型，该枚举类型的使用说明详见 3.1.1.5 节；
- **OMX_STATETYPE**：详见 3.1.1.2 节。

#### 3.1.1.1 OMX_COMMANDTYPE
表 3-1 列出了 IL 客户端可发送给 OpenMAX IL 组件的所有可能命令。由于命令为非阻塞式（non-blocking），因此当命令执行完成后，OpenMAX IL 组件会通过回调函数生成命令完成事件（command completion event）。回调函数定义在一个专用结构中，详见 3.1.2.8 节。

**表 3-1：OpenMAX IL 命令（OpenMAX IL Commands）**

| 字段名称（Field Name） | 描述（Description） |
|------------------------|---------------------|
| OMX_CommandStateSet    | 更改组件状态（Change the component state） |
| OMX_CommandFlush       | 清空组件某个端口上的缓冲区队列（Flush the queue(s) of buffers on a port of a component） |
| OMX_CommandPortDisable | 禁用组件的某个端口（Disable a port on a component） |
| OMX_CommandPortEnable  | 启用组件的某个端口（Enable a port on a component） |
| OMX_CommandMarkBuffer  | 标记一个缓冲区，并指定哪个其他组件将触发“标记已接收”事件（Mark a buffer and specify which other component will raise the event mark received） |

表 3-2 描述了每个命令需使用的参数。

**表 3-2：命令语法（Command Syntax）**

| 命令代码（Command code） | nParam 参数（nParam） | pCmdData 参数（pCmdData） |
|---------------------------|------------------------|---------------------------|
| OMX_CommandStateSet       | OMX_STATETYPE – 需切换到的目标状态（state to transition to） | NULL |
| OMX_CommandFlush          | OMX_U32 – 目标端口 ID（target port ID） | NULL |
| OMX_CommandPortDisable    | OMX_U32 – 目标端口 ID（target port ID） | NULL |
| OMX_CommandPortEnable     | OMX_U32 – 目标端口 ID（target port ID） | NULL |
| OMX_CommandMarkBuffer     | OMX_U32 – 目标端口 ID（target port ID） | OMX_MARKTYPE* – 标记数据与目标组件（mark data and target component） |

#### 3.1.1.2 OMX_STATETYPE
图 3-1 展示了 IL 客户端调用 `OMX_SendCommand(OMX_StateSet, <state>)`（其中组件的新状态以参数形式传递）时，组件的状态转换过程。名称被 `<` 和 `>` 括号包围的转换表示：该转换并非由 IL 客户端发送的命令触发，而是由组件内部事件（internal component events）导致。

本节将介绍组件的状态。IL 客户端通过 `OMX_SendCommand` 函数发送 `OMX_CommandStateSet` 命令，可指令组件进行状态转换。

表 3-3 列出了 OpenMAX IL 组件的所有状态。

**表 3-3：OpenMAX IL 组件状态（OpenMAX IL Component States）**

| 字段名称（Field Name） | 描述（Description） | 静态资源已分配（Static Resources Allocated） | 缓冲区位置（Location of buffer） |
|------------------------|---------------------|-----------------------------------------------|----------------------------------|
| OMX_StateInvalid       | 组件已损坏，或遇到无法恢复的错误（Component is corrupt or has encountered an error from which it cannot recover） | 未知（Unknown） | 未知（Unknown） |
| OMX_StateLoaded        | 组件已加载，但未分配任何资源（Component has been loaded but has no resources allocated） | 否（No） | 不可用（Not available） |
| OMX_StateIdle          | 组件已获取所有资源，但未传输任何缓冲区或开始处理数据（Component has all resources but has not transferred any buffers or begun processing data） | 是（Yes） | 仅提供者（Supplier only） |
| OMX_StateExecuting     | 组件正在传输缓冲区并处理数据（若有可用数据）（Component is transferring buffers and is processing data (if data is available)） | 是（Yes） | 提供者或非提供者（Supplier or non-supplier） |
| OMX_StatePause         | 组件的数据处理已暂停，但可从暂停点恢复（Component data processing has been paused but may be resumed from the point it was paused） | 是（Yes） | 提供者或非提供者（Supplier or non-supplier） |
| OMX_StateWaitForResources | 组件正在等待某个资源变为可用（Component is waiting for a resource to become available） | 否（No） | 不可用（Not available） |

##### 3.1.1.2.1 OMX_StateLoaded
组件通过 `OMX_GetHandle` 调用创建后、资源分配前，处于 **OMX_StateLoaded** 状态。在此状态下，IL 客户端可执行以下操作：
- 通过 `OMX_SetParameter` 修改组件参数；
- 通过 `OMX_SetupTunnel` 在组件端口上设置数据隧道；
- 将组件转换到 **OMX_StateIdle** 状态或 **OMX_StateWaitForResources** 状态。

若组件在尝试转换到 **OMX_StateIdle** 状态时，未能获取所有静态资源（static resources），IL 客户端可选择将当前处于 **OMX_StateLoaded** 状态的组件转换到 **OMX_StateWaitForResources** 状态。

###### 3.1.1.2.1.1 从 OMX_StateLoaded 转换到 OMX_StateIdle
若 IL 客户端请求组件从 **OMX_StateLoaded** 状态转换到 **OMX_StateIdle** 状态，组件需在转换完成前获取所有静态资源（包括所有已启用端口的缓冲区），但无需为未启用的端口获取缓冲区。此外，在转换完成前，缓冲区提供者（非隧道场景下始终为 IL 客户端）需确保非提供者（non-supplier）已持有其所有缓冲区。

对于与 IL 客户端通信的端口，IL 客户端可通过以下两种方式为端口分配缓冲区：
1. 自行分配缓冲区，再通过该端口的 `OMX_UseBuffer` 调用将缓冲区传递给端口；
2. 通过该端口的 `OMX_AllocateBuffer` 调用，指令端口自行执行分配操作。

对于每个端口，IL 客户端需仅使用 `OMX_UseBuffer` 或 `OMX_AllocateBuffer` 中的一种方式。

当端口处于隧道模式（tunneling）时，提供者端口（supplier port）可选择以下两种方式处理缓冲区：
1. 自行分配缓冲区；
2. 若端口支持缓冲区共享（buffer sharing），则复用同一组件上另一个端口的缓冲区。

随后，提供者端口会通过非提供者端口的 `OMX_UseBuffer` 调用，将缓冲区传递给非提供者端口。

端口使用的缓冲区数量在其端口定义（详见 `OMX_IndexParamPortDefinition`）中指定，默认值为该结构中规定的最小值（minimum），但提供者可在调用 `OMX_UseBuffer` 和 `OMX_AllocateBuffer` 前，通过 `OMX_SetParameter` 调用修改该数量。

##### 3.1.1.2.2 OMX_StateIdle
在 **OMX_StateIdle** 状态下，组件已完成所有必要静态资源的分配，可随时投入使用。但此时提供者仍持有所有缓冲区，未发生缓冲区交换或数据处理。因此，若组件从 **OMX_StateExecuting** 或 **OMX_StatePause** 状态进入 **OMX_StateIdle** 状态，需将其正在处理的所有缓冲区归还给各自的提供者。

IL 客户端可将处于 **OMX_StateIdle** 状态的组件转换到除 **OMX_StateInvalid** 和 **OMX_StateWaitForResources** 之外的所有状态。

###### 3.1.1.2.2.1 从 OMX_StateIdle 转换到 OMX_StateLoaded
当组件从 **OMX_StateIdle** 状态转换到 **OMX_StateLoaded** 状态时，每个缓冲区提供者需对非提供者端口上的每个缓冲区调用 `OMX_FreeBuffer`。具体规则如下：
- 若缓冲区由提供者分配，则提供者需在调用 `OMX_FreeBuffer` 前释放该缓冲区；
- 若缓冲区由非提供者端口分配，则非提供者端口需在收到 `OMX_FreeBuffer` 调用后释放该缓冲区；
- 无论缓冲区由谁分配，非提供者端口在收到 `OMX_FreeBuffer` 调用后，均需释放缓冲区头（buffer header）。

当组件的所有缓冲区均被移除后，状态转换完成，组件会通过回调事件（callback event）告知 IL 客户端：触发此次转换的 `OMX_SendCommand` 调用已执行完成。

###### 3.1.1.2.2.2 从 OMX_StateIdle 转换到 OMX_StateExecuting
若组件处于暂停（suspended）状态，则不允许从 **OMX_StateIdle** 转换到 **OMX_StateExecuting** 状态。具体规则如下：
- 若 IL 客户端请求转换时组件未暂停，组件需开始传输并处理数据；
- 若 IL 客户端请求转换时组件已暂停，组件需拒绝该调用，并返回 `OMX_ErrorComponentSuspended` 错误。

对于与 IL 客户端通信的端口，IL 客户端需通过 `OMX_EmptyThisBuffer` 和 `OMX_FillThisBuffer` 触发缓冲区传输；对于隧道端口（tunneling ports），任何同时作为提供者的输入端口（input port），需通过 `OMX_FillThisBuffer` 将空缓冲区传输给隧道输出端口（tunneled output port）。

##### 3.1.1.2.3 OMX_StateExecuting
在 **OMX_StateExecuting** 状态下，OpenMAX IL 组件正在传输和处理数据缓冲区，且此时组件不可暂停。组件需支持以下操作：
- 接收对其输入端口的 `OMX_EmptyThisBuffer` 调用；
- 接收对其输出端口的 `OMX_FillThisBuffer` 调用。

不同类型端口的缓冲区返回规则如下：
- 与 IL 客户端通信的端口：需调用 `EmptyBufferDone` 和 `FillBufferDone` 回调函数，分别将空缓冲区和满缓冲区归还给 IL 客户端；
- 隧道端口：需调用对应隧道端口的 `OMX_FillThisBuffer` 或 `OMX_EmptyThisBuffer`，分别将空缓冲区和满缓冲区归还给对应隧道端口。

IL 客户端可将处于 **OMX_StateExecuting** 状态的组件转换到 **OMX_StateIdle** 或 **OMX_StatePause** 状态。

###### 3.1.1.2.3.1 从 OMX_StateExecuting 转换到 OMX_StateIdle
若 IL 客户端请求组件从 **OMX_StateExecuting** 状态转换到 **OMX_StateIdle** 状态，组件需在转换完成前完成以下操作：
1. 将所有缓冲区归还给各自的提供者；
2. 接收其提供者端口所属的所有缓冲区。

不同类型端口的缓冲区处理规则如下：
- 与 IL 客户端通信的端口：需通过 `EmptyBufferDone`（输入端口）和 `FillBufferDone`（输出端口）回调函数，返回其持有的所有缓冲区；
- 非提供者端口：需通过 `OMX_EmptyThisBuffer`（输入端口）或 `OMX_FillThisBuffer`（输出端口），将其持有的所有缓冲区归还给对应的隧道端口；
- 提供者隧道端口：需等待其所有缓冲区从对应隧道端口返回。

###### 3.1.1.2.3.2 从 OMX_StateExecuting 转换到 OMX_StatePause
组件从 **OMX_StateExecuting** 状态转换到 **OMX_StatePause** 状态的场景分为以下 3 种：
1. IL 客户端显式请求转换；
2. 组件丢失执行所需的资源，但后续若重新获取该资源，可从资源丢失点恢复执行：此时组件会自动执行转换，并触发错误事件（error event），返回 `OMX_ErrorResourcesSuspended` 错误；
3. 组件尝试分配动态资源（dynamic resources）失败：此时组件会自动执行转换，并触发错误事件，返回 `OMX_ErrorDynamicResourcesUnavailable` 错误。

##### 3.1.1.2.4 OMX_StatePause
在 **OMX_StatePause** 状态下，OpenMAX IL 组件不会传输或处理数据，但缓冲区无需归还给提供者。组件可从该状态转换到 **OMX_StateExecuting** 状态以恢复执行（优先保证不丢失数据），但需遵循以下规则：
- 若 IL 客户端请求转换时组件未暂停，转换正常执行；
- 若 IL 客户端请求转换时组件已暂停，组件需拒绝该调用，并返回 `OMX_ErrorResourcesSuspended` 错误。

此外，处于 **OMX_StatePause** 状态的组件仍可接收输入端口的数据缓冲区，但这些缓冲区仅会被排队（queued），不会进一步处理。IL 客户端可将处于该状态的组件转换到 **OMX_StateIdle** 或 **OMX_StateExecuting** 状态。

当组件从 **OMX_StatePause** 状态转换到 **OMX_StateIdle** 状态时，需按照 3.1.1.2.3.1 节中“从 OMX_StateExecuting 转换到 OMX_StateIdle”的规则，将所有缓冲区归还给各自的提供者。

##### 3.1.1.2.5 OMX_StateWaitForResources
在 **OMX_StateWaitForResources** 状态下，组件正在等待一个或多个所需资源变为可用。该状态与资源管理（resource management）相关，其前提是平台上存在一个或多个特定于硬件的资源管理器（hardware-specific resource managers），用于管理可用资源。OpenMAX IL 组件与资源管理器之间的交互不在本规范的范围内。

若处于 **OMX_StateLoaded** 状态的组件因资源不足（非缓冲区资源）而无法进入 **OMX_StateIdle** 状态，且 IL 客户端希望在所需资源可用时收到通知，则可将组件设置为 **OMX_StateWaitForResources** 状态。IL 客户端可通过将组件从 **OMX_StateWaitForResources** 状态转换到 **OMX_StateLoaded** 状态，指令组件停止等待资源。

若处于 **OMX_StateWaitForResources** 状态的组件获取到了其等待的所有资源，则会自动触发转换，进入 **OMX_StateIdle** 状态。

###### 3.1.1.2.5.1 从 OMX_StateWaitForResources 转换到 OMX_StateIdle
当组件触发从 **OMX_StateWaitForResources** 到 **OMX_StateIdle** 的状态转换时，需通过 `OMX_EventResourcesAcquired` 事件将转换启动的通知发送给 IL 客户端。IL 客户端收到该事件后，需按照“从 OMX_StateLoaded 转换到 OMX_StateIdle”的方式，调用 `OMX_UseBuffer` 和 `OMX_AllocateBuffer`。此外，组件需获取所有静态资源（包括缓冲区）后，才能完成到 **OMX_StateIdle** 状态的转换。

##### 3.1.1.2.6 OMX_StateInvalid
在 **OMX_StateInvalid** 状态下，组件已发生内部损坏或遇到无法恢复的错误。当组件检测到此类情况时，会自动转换到该状态，并通过生成 `OMX_EventError` 事件（携带 `OMX_ErrorInvalidState` 错误值）告知 IL 客户端。

IL 客户端收到指示“转换到 OMX_StateInvalid 状态”的 `OMX_EventError` 事件后，需释放与该组件相关的所有资源，并最终调用 `OMX_FreeHandle` 释放与该组件关联的句柄（handle）。

处于 **OMX_StateInvalid** 状态的组件，除 `OMX_GetState`、`OMX_FreeBuffer` 和 `OMX_ComponentDeinit` 外，会拒绝所有其他调用，并返回 `OMX_ErrorInvalidState` 错误。此外，IL 客户端也可通过 `OMX_SendCommand` 显式指令组件转换到 **OMX_StateInvalid** 状态，组件可从任何状态转换到该状态。

#### 3.1.1.3 OMX_ERRORTYPE
表 3-4 所示的 **OMX_ERRORTYPE** 枚举定义了 OpenMAX IL API 中所有函数返回的标准 OpenMAX IL 错误（standard OpenMAX IL errors），这些错误可覆盖大多数常见故障场景。厂商可自行添加额外错误信息，但需遵循以下规则：
1. 厂商错误信息的取值范围需为 0x90000000 至 0x9000FFFF；
2. 厂商错误信息需定义在组件随附的头文件中，不允许使用未定义的错误信息。

**表 3-4：OpenMAX IL 错误码（OpenMAX IL Error Codes）**

| 字段名称（Field Name） | 描述（Description） |
|------------------------|---------------------|
| OMX_ErrorNone | 函数执行成功（The function returned successfully） |
| OMX_ErrorInsufficientResources | 资源不足，无法执行请求的操作（There were insufficient resources to perform the requested operation） |
| OMX_ErrorUndefined | 发生错误，但无法确定错误原因（There was an error but the cause of the error could not be determined） |
| OMX_ErrorInvalidComponentName | 组件名称字符串无效（The component name string was invalid） |
| OMX_ErrorComponentNotFound | 未找到与指定名称字符串匹配的组件（No component with the specified name string was found） |
| OMX_ErrorInvalidComponent | 指定的组件不存在 `OMX_ComponentInit` 入口点，或组件未正确完成 `OMX_ComponentInit` 调用（The component specified did not have a OMX_ComponentInit entry point, or the component did not correctly complete the OMX_ComponentInit call） |
| OMX_ErrorBadParameter | 一个或多个参数无效（One or more parameters were invalid） |
| OMX_ErrorNotImplemented | 请求的函数未实现（The requested function is not implemented） |
| OMX_ErrorUnderflow | 下一个缓冲区未准备好前，当前缓冲区已被清空（The buffer was emptied before the next buffer was ready） |
| OMX_ErrorOverflow | 需要缓冲区时，缓冲区不可用（The buffer was not available when it was needed） |
| OMX_ErrorHardware | 硬件未按预期响应（The hardware failed to respond as expected） |
| OMX_ErrorInvalidState | 组件处于 OMX_StateInvalid 状态（The component is in the OMX_StateInvalid state） |
| OMX_ErrorStreamCorrupt | 检测到流损坏（The stream is found to be corrupt）。处理编码数据的 OpenMAX IL 组件（通常为解码器）可检测数据流中的损坏，也可检测丢失的帧并执行错误隐藏（error concealment）。此类组件应按帧向客户端报告此类错误（使用此错误码）。注：大多数情况下，组件会继续正常运行 |
| OMX_ErrorPortsNotCompatible | 为隧道通信（tunneled communication）配置的端口不兼容（Ports being set up for tunneled communication are incompatible） |
| OMX_ErrorResourcesLost | 处于 OMX_StateIdle 状态的组件所分配的资源已丢失，导致组件返回 OMX_StateLoaded 状态（Resources allocated to a component in the OMX_StateIdle state have been lost, which has resulted in the component returning to the OMX_StateLoaded state） |
| OMX_ErrorNoMore | 无法再枚举更多索引（No more indices can be enumerated） |
| OMX_ErrorVersionMismatch | 组件检测到版本不匹配（The component detected a version mismatch） |
| OMX_ErrorNotReady | 组件当前无法返回数据（The component is not ready to return data at this time） |
| OMX_ErrorTimeout | 超时：组件无法在合理时间内处理调用（A timeout occurred where the component was unable to process the call in a reasonable amount of time），可能由无限循环或硬件繁忙导致 |
| OMX_ErrorSameState | 组件尝试转换到当前所处的状态（The component tried to transition into the state that it is currently in） |
| OMX_ErrorResourcesPreempted | 处于 OMX_StateExecuting 或 OMX_StatePause 状态的组件所分配的资源已被抢占，导致组件返回 OMX_StateIdle 状态（Resources allocated to a component in the OMX_StateExecuting or OMX_StatePause states have been preempted, causing the component to return to the OMX_StateIdle state） |
| OMX_ErrorPortUnresponsiveDuringAllocation | 非提供者端口等待提供者端口通过 OMX_UseBuffer 调用发送已分配缓冲区的时间过长（The non-supplier port deemed that it had waited an unusually long time for the supplier port to send it an allocated buffer via an OMX_UseBuffer call）。非提供者端口会在“从 LOADED 状态转换到 IDLE 状态”或“端口启用”过程中的缓冲区分配阶段，通过 EventHandler 回调向 IL 客户端发送此错误 |
| OMX_ErrorPortUnresponsiveDuringDeallocation | 非提供者端口等待提供者端口通过 OMX_FreeBuffer 调用请求释放缓冲区头的时间过长（The non-supplier port deemed that it had waited an unusually long time for the supplier port to request the de-allocation of a buffer header via a OMX_FreeBuffer call）。非提供者端口会在“从 IDLE 状态转换到 LOADED 状态”或“端口禁用”过程中的缓冲区释放阶段，通过 EventHandler 回调向 IL 客户端发送此错误 |
| OMX_ErrorPortUnresponsiveDuringStop | 提供者端口等待非提供者端口通过 EmptyThisBuffer 或 FillThisBuffer 调用返回缓冲区的时间过长（The supplier port deemed that it had waited an unusually long time for the non-supplier port to return a buffer via an EmptyThisBuffer or FillThisBuffer call）。提供者端口会在“端口禁用”过程中（包括“从 IDLE 状态转换到 LOADED 状态”或“端口禁用”场景），通过 EventHandler 回调向 IL 客户端发送此错误 |
| OMX_ErrorIncorrectStateTransition | 尝试执行不允许的状态转换（A state transition was attempted that is not allowed） |
| OMX_ErrorIncorrectStateOperation | 在当前状态下尝试执行不允许的命令或方法（A command or method was attempted that is not allowed during the present state） |
| OMX_ErrorUnsupportedSetting | 参数或配置结构中包含一个或多个不支持的值（One or more values encapsulated in the parameter or configuration structure are unsupported） |
| OMX_ErrorUnsupportedIndex | 指定索引对应的参数或配置不支持（The parameter or configuration indicated by the given index is unsupported） |
| OMX_ErrorBadPortIndex | 提供的端口索引不正确（The port index that was supplied is incorrect） |
| OMX_ErrorPortUnpopulated | 端口已丢失一个或多个缓冲区，导致无法正常运行（The port has lost one or more of its buffers and is thus unpopulated） |
| OMX_ErrorComponentSuspended | 组件因资源临时丢失而暂停（Component suspended due to temporary loss of resources） |
| OMX_ErrorDynamicResourcesUnavailable | 组件因无法获取动态资源而暂停（Component suspended due to inability to acquire dynamic resources） |
| OMX_ErrorMbErrorsInFrame | 检测到帧内宏块错误（Errors detected in frame） |
| OMX_ErrorFormatNotDetected | 读取输入缓冲区或内容管道（Content Pipe）时执行解析操作的 OpenMAX IL 组件，可检查输入数据的格式正确性（OMX IL components performing parsing when reading input buffers or content pipes have the ability to check correct formatting of input data）。当组件无法解析或确定给定数据流的格式时，需通过 EventHandler 回调向客户端发送 OMX_EventError 事件（使用此错误码）。注：文件解析错误场景下仅报告一次；其他场景下，每次数据单元（如帧）格式错误均需报告 |
| OMX_ErrorContentPipeOpenFailed | 内容管道（Content Pipe）打开失败（Opening the Content Pipe failed） |
| OMX_ErrorContentPipeCreationFailed | 内容管道（Content Pipe）创建失败（Creating the Content Pipe failed） |
| OMX_ErrorSeperateTablesUsed | 当色度（Cb 和 Cr）系数使用单独的量化表时，尝试查询单个色度表（Attempting to query for single Chroma table when separate quantization tables are used for the Chroma (Cb and Cr) coefficients） |
| OMX_ErrorTunnelingUnsupported | 组件不支持隧道模式（Tunneling is not supported by the component） |


# 3.1.1.4 OMX_EVENTTYPE
表 3-5 所示的 **OMX_EVENTTYPE** 枚举包含 OpenMAX IL 组件可生成的所有事件类型。3.1.2.8 节将介绍 OpenMAX IL 组件通过回调机制（callback mechanism）生成并传递给 IL 客户端的事件，这些事件会携带相关参数，且参数也会在回调中传递。

**表 3-5：OpenMAX IL 事件类型（OpenMAX IL Event Types）**

| 字段名称（Field Name） | 描述（Description） |
|------------------------|---------------------|
| OMX_EventCmdComplete | 组件已完成命令的执行（Component has completed the execution of a command） |
| OMX_EventError | 组件检测到错误状态（Component has detected an error condition） |
| OMX_EventMark | 带标记的缓冲区已到达目标组件，IL 客户端已收到携带该标记私有数据指针的事件（A buffer mark has reached the target component, and the IL client has received this event with the private data pointer of the mark） |
| OMX_EventPortSettingsChanged | 组件的端口设置已变更（例如，组件因解析码流而修改端口设置）（Component has changed port settings. For example, the component has changed port settings resulting from bit stream parsing） |
| OMX_EventBufferFlag | 组件检测到流结束时发送的事件（The event that a component sends when it detects the end of a stream） |
| OMX_EventResourcesAcquired | 组件已获取所需资源，正从 OMX_StateWaitForResources 状态转换到 OMX_StateIdle 状态（The component has been granted resources and is transitioning from the OMX_StateWaitForResources state to the OMX_StateIdle state） |
| OMX_EventComponentResumed | 组件因重新获取资源而恢复运行（即不再处于暂停状态）（The component has been resumed (i.e. no longer suspended) due to reacquisition of resources） |
| OMX_EventDynamicResourcesAvailable | 组件已获取此前无法分配的动态资源（The component has acquired previously unavailable dynamic resources） |


## 3.1.1.4.1 OMX_EventCmdComplete
当 IL 客户端发送的命令完成执行，或组件主动触发的状态转换发生时，组件会立即生成 **OMX_EventCmdComplete** 事件。若事件与组件状态变更相关（无论变更由 IL 客户端还是组件主动触发），组件进入的新状态会作为事件参数返回。需注意：转换到 OMX_StateInvalid 状态的组件不会生成此事件。


## 3.1.1.4.2 OMX_EventError
当组件检测到错误状态时，会生成 **OMX_EventError** 事件，检测到的错误类型会作为事件参数返回，且错误类型取值需符合 **OMX_ERRORTYPE** 中定义的值。组件需通过 OMX_EventError 发送以下类型的错误：
- 若组件转换到 OMX_StateInvalid 状态，需发送 OMX_ErrorInvalidState 错误；
- 若组件因资源丢失从 OMX_StateExecuting 或 OMX_StatePause 状态转换到 OMX_StateIdle 状态，需发送 OMX_ErrorResourcesPreempted 错误；
- 若组件因资源丢失从 OMX_StateIdle 状态转换到 OMX_StateLoaded 状态，需发送 OMX_ErrorResourcesLost 错误。


## 3.1.1.4.3 OMX_EventMark
当组件收到带标记的缓冲区（marked buffer）时，会生成 **OMX_EventMark** 事件。组件收到缓冲区后，需将自身句柄（handle）与缓冲区中包含的 `pMarkTargetComponent` 字段进行比对：若两者匹配，组件需在完成该缓冲区处理后，立即发送标记事件（mark event），并将 `pMarkData` 作为参数传入。

IL 客户端可利用此标记事件实现以下功能：
1. 测量数据缓冲区在组件链（chain of components）中的传播延迟；
2. 通知某个组件：特定缓冲区已到达指定目标。


## 3.1.1.4.4 OMX_EventPortSettingsChanged
当组件的端口设置发生变更时，组件会立即生成 **OMX_EventPortSettingsChanged** 事件。例如，视频解码器可能无法预先知晓输出帧尺寸（output frame size）和帧率（frame rate）（这些参数编码在输入码流中），当解码器解析出这些参数后，会修改其输出端口的配置结构（configuration structures）值，并向 IL 客户端发送 OMX_EventPortSettingsChanged 事件。

若端口设置变更要求 IL 客户端执行以下操作，则触发该事件的端口需停止数据传输，直至 IL 客户端完成操作：
1. 重新分配缓冲区（reallocate buffers）；
2. 重新初始化该端口上的隧道（recycle the tunnel）。


## 3.1.1.4.5 OMX_EventBufferFlag
当输出端口发送的缓冲区中，`nFlags` 字段设置了 `OMX_BUFFERFLAG_EOS` 标志时，组件会生成 **OMX_EventBufferFlag** 事件。此时：
- `EventHandler` 的 `nData1` 字段指定输出端口的端口索引（portindex）值；
- `EventHandler` 的 `nData2` 字段指定未修改的 `nFlags` 字段（包含流结束（EOS）标志）。

若组件不再向下游传播流（例如，该组件是音频接收器或视频接收器），则当组件处理完 `OMX_BUFFERFLAG_EOS` 标志置位的缓冲区后，需为该流发送 OMX_EventBufferFlag 事件。此时：
- `EventHandler` 的 `nData1` 字段指定接收该缓冲区的输入端口；
- `EventHandler` 的 `nData2` 字段指定未修改的 `nFlags` 字段（包含 EOS 标志）。


## 3.1.1.4.6 OMX_EventResourcesAcquired
当组件处于 OMX_StateWaitForResources 状态，且资源管理器（resource manager）检测到所需资源可用时，组件会生成 **OMX_EventResourcesAcquired** 事件。组件生成此事件后，已准备好转换到 OMX_StateIdle 状态，并会等待所有缓冲区完成分配并分配给其端口。


## 3.1.1.4.7 OMX_EventComponentResumed
当处于暂停状态的组件重新获取其此前丢失的资源时，会生成 **OMX_EventComponentResumed** 事件。IL 客户端收到此事件后，表明组件已不再处于暂停状态，可尝试将该组件转换到执行状态（executing state）。


## 3.1.1.4.8 OMX_EventDynamicResourcesAvailable
当处于暂停状态的组件获取到此前无法分配的动态资源时，会生成 **OMX_EventDynamicResourcesAvailable** 事件。IL 客户端收到此事件后，表明组件已不再处于暂停状态，可尝试将该组件转换到执行状态。


## 3.1.1.5 OMX_BUFFERSUPPLIERTYPE
表 3-6 所示的 **OMX_BUFFERSUPPLIERTYPE** 枚举类型指定了隧道中作为提供者端口（supplier port）的端口。提供者端口可选择以下两种方式处理缓冲区：
1. 自行分配缓冲区；
2. 复用同一组件内其他端口提供的缓冲区。

**表 3-6：用于隧道设置的 OpenMAX IL 缓冲区提供者类型（OpenMAX IL Buffer Supplier Type For Tunnel Setup）**

| 字段名称（Field Name） | 描述（Description） |
|------------------------|---------------------|
| OMX_BufferSupplyUnspecified | 未指定缓冲区提供者端口，或无首选提供者（The port supplying the buffers is unspecified, or no supplier is preferred） |
| OMX_BufferSupplyInput | 输入端口作为缓冲区提供者（The input port supplies the buffers） |
| OMX_BufferSupplyOutput | 输出端口作为缓冲区提供者（The output port supplies the buffer） |


# 3.1.2 结构（Structures）
本节将介绍 OpenMAX IL 核心中定义的数据结构。每个 OpenMAX IL 数据结构的前两个字段固定为：
1. `nSize`：结构的大小（以字节为单位）；
2. `nVersion`：类型为 **OMX_VERSIONTYPE** 的版本字段（定义见 3.1.2.4 节）。

分配 OpenMAX IL 结构的实体需负责填充这两个字段的值。在后续各结构的定义中，将省略这两个通用字段的说明。


## 3.1.2.1 OMX_COMPONENTREGISTERTYPE
**OMX_COMPONENTREGISTERTYPE** 结构用于组件与核心（core）静态链接（static linking）的场景。核心可选择性地使用该结构加载组件，并运行特定的组件初始化函数（component initialization functions）。

OMX_COMPONENTREGISTERTYPE 的定义如下：
```c
typedef struct OMX_COMPONENTREGISTERTYPE
{
  const char * pName;
  OMX_COMPONENTINITTYPE pInitialize;
} OMX_COMPONENTREGISTERTYPE;
```


## 3.1.2.2 OMX_COMPONENTINITTYPE 类型定义
**OMX_COMPONENTINITTYPE** 是组件初始化入口点（component initialization entry point）的函数指针类型，定义如下：
```c
typedef OMX_ERRORTYPE (* OMX_COMPONENTINITTYPE)(OMX_IN OMX_HANDLETYPE hComponent);
```


### 3.1.2.2.1 参数定义（Parameter Definitions）
- `pName`：包含组件的字符串名称，长度限制为 128 字节（含终止符 `\0`）；
- `pInitialize`：指向组件初始化函数的指针。


## 3.1.2.3 OMX_ComponentRegistered[ ]
所有采用静态链接组件的核心，均需定义此全局数组。数组以 **OMX_COMPONENTREGISTERTYPE** 字段的形式，存储所有已注册组件的列表。


## 3.1.2.4 OMX_VERSIONTYPE
**OMX_VERSIONTYPE** 类型用于表示组件或结构的版本，具体规则如下：
1. 每个结构均通过 OMX_VERSIONTYPE 字段，指明该结构所遵循的 OpenMAX IL 规范版本：
   - OpenMAX IL 1.0 版本：规范版本格式为 1.0.R.S（R 为修订号（Revision），S 为步骤号（Step），取值不限）；
   - OpenMAX IL 1.1 版本：规范版本格式为 1.1.R.S（R、S 取值不限）；
2. 组件结构中也包含 OMX_VERSIONTYPE 字段，用于表示厂商自定义的组件版本。

OMX_VERSIONTYPE 的定义如下：
```c
typedef union OMX_VERSIONTYPE
{
  struct
  {
    OMX_U8 nVersionMajor;
    OMX_U8 nVersionMinor;
    OMX_U8 nRevision;
    OMX_U8 nStep;
  } s;
  OMX_U32 nVersion;
} OMX_VERSIONTYPE;
```


### 3.1.2.4.1 参数定义（Parameter Definitions）
- `nVersionMajor`：主版本号（Major Version Number），在版本字段中排在首位；
- `nVersionMinor`：次版本号（Minor Version Number）；
- `nRevision`：修订号（Revision Number）；
- `nStep`：步骤号（Step Number），在版本字段中排在末位。


## 3.1.2.5 OMX_PRIORITYMGMTTYPE
IL 客户端可将 **OMX_IndexConfigPriorityMgmt** 和 **OMX_IndexParamPriorityMgmt** 参数与 **OMX_PRIORITYMGMTTYPE** 结构配合使用，该结构用于描述分配给一组组件的优先级（priority）。

### 核心概念：组件组（Component Group）
组件组是指与同一功能相关联的一组相互依赖的组件，同一组件组内的所有组件共享相同的组 ID（group ID）和优先级：
- 若组内某个组件因丢失资源而停止运行，则该组共同提供的功能将失效，此时 IL 客户端应将组内其他所有组件转换到 OMX_StateLoaded 状态；
- 若某个组件的 `nGroupID` 唯一（即组内仅包含该组件），则该组件的运行具有原子性（atomically）。

OMX_PRIORITYMGMTTYPE 的定义如下：
```c
typedef struct OMX_PRIORITYMGMTTYPE {
  OMX_U32 nSize;
  OMX_VERSIONTYPE nVersion;
  OMX_U32 nGroupPriority;
  OMX_U32 nGroupID;
} OMX_PRIORITYMGMTTYPE;
```


### 3.1.2.5.1 参数定义（Parameter Definitions）
- `nGroupPriority`：分配给组件组的优先级值。若某个组件被分配此类型的参数，则该组件属于 `nGroupID` 标识的组，且优先级等于 `nGroupPriority`。根据定义，值为 0 表示组件组的最高优先级。  
  注：为组件组分配优先级的具体机制不在本文档范围内；同一组件组的优先级视为相同，若修改组内某个组件的优先级，则该修改对组内所有组件生效，IL 客户端需将组内所有组件的优先级更新为相同值；组内某个组件暂停，不意味着组内所有组件均需暂停。
- `nGroupID`：同一组件组内所有组件的唯一标识 ID。


## 3.1.2.6 OMX_RESOURCECONCEALMENTTYPE
IL 客户端可将 **OMX_IndexParamDisableResourceConcealment** 参数与 **OMX_RESOURCECONCEALMENTTYPE** 结构配合使用，以启用或禁用组件中的资源隐藏（resource concealment）功能。

OMX_RESOURCECONCEALMENTTYPE 的定义如下：
```c
typedef struct OMX_RESOURCECONCEALMENTTYPE
{
  OMX_U32 nSize;
  OMX_VERSIONTYPE nVersion;
  OMX_BOOL bResourceConcealmentForbidden;
} OMX_RESOURCECONCEALMENTTYPE;
```


### 3.1.2.6.1 参数定义（Parameter Definitions）
- `bResourceConcealmentForbidden`：布尔值（Boolean），若设为真（TRUE），则禁止组件使用资源隐藏方法解决资源冲突（resource conflicts）。


### 3.1.2.6.2 组件暂停策略（Component Suspension Policy）
若组件因资源不足无法处理数据，可选择暂停自身（suspend itself）以解决临时资源冲突。当资源丢失为暂时性，或冲突由运行时需要额外动态资源导致时，组件暂停是理想的解决方案。

IL 客户端可通过 **OMX_IndexParamSuspensionPolicy** 参数指定组件的暂停策略，支持的策略包括：
1. **暂停禁用（Suspension Disabled）**：  
   组件不得暂停自身。若处于执行状态（executing）的组件丢失资源，需先转换到空闲状态（idle），再转换到加载状态（loaded），以此处理资源丢失。这是 OpenMAX IL 1.0 版本中定义的组件默认行为。
2. **暂停启用（Suspension Enabled）**：  
   当组件检测到资源临时丢失时，可暂停数据处理。若暂停发生在暂停状态（paused）或空闲状态（idle），则不触发状态转换；若暂停发生在执行状态（executing），则组件需转换到暂停状态（paused）。


#### 暂停策略相关结构定义
1. **OMX_PARAM_SUSPENSIONPOLICYTYPE**  
   用于指定组件的暂停策略，定义如下：
   ```c
   typedef struct OMX_PARAM_SUSPENSIONPOLICYTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_SUSPENSIONPOLICYTYPE ePolicy;
   } OMX_PARAM_SUSPENSIONPOLICYTYPE;
   ```
   参数说明：  
   - `ePolicy`：指定组件是否支持暂停：`OMX_SuspensionEnabled` 表示启用暂停，`OMX_SuspensionDisabled` 表示禁用暂停。组件默认值为 `OMX_SuspensionDisabled`。

2. **OMX_PARAM_SUSPENSIONTYPE**  
   IL 客户端可通过 **OMX_IndexParamComponentSuspended** 参数查询组件是否处于暂停状态，并根据组件的暂停状态决定后续操作（例如，保持组件当前状态以等待暂停结束，或转换组件到加载状态，或执行其他处理）。该结构定义如下：
   ```c
   typedef struct OMX_PARAM_SUSPENSIONTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_SUSPENSIONTYPE eType;
   } OMX_PARAM_SUSPENSIONTYPE;
   ```
   参数说明：  
   - `eType`：指定组件的暂停状态：`OMX_Suspended` 表示组件处于暂停状态，`OMX_NotSuspended` 表示组件未处于暂停状态。


### 3.1.2.6.3 因资源抢占导致的暂停（Suspension Due to Pre-emption of Resources）
“暂停”对组件实现的影响较小，具体规则如下：
1. 当组件丢失一个或多个资源时，需在以下两种处理方式中选择：
   - 若组件支持后续恢复且暂停策略允许，可暂停自身；
   - 若组件不支持后续恢复或暂停策略禁止，需通过 `OMX_ErrorResourcesPreempted`/`OMX_ErrorResourcesLost` 错误进行反初始化（de-initializing）。
2. 组件暂停时，需向 IL 客户端发送 `OMX_ErrorComponentSuspended` 错误；若暂停发生在执行状态（executing），组件需自行转换到暂停状态（paused），并向 IL 客户端发送 `OMX_EventCmdComplete` 事件。
3. 组件需支持 **OMX_IndexParamComponentSuspended** 参数（用于查询暂停状态）。
4. 当 IL 客户端请求组件转换到执行状态（executing）时，组件需先验证自身是否处于暂停状态：若处于暂停状态，需拒绝该转换并返回 `OMX_ErrorComponentSuspended` 错误。
5. 组件重新获取资源后，需通过 `OMX_EventComponentResumed` 事件通知 IL 客户端，并保持在暂停状态（paused），直至 IL 客户端将其转换回执行状态（executing）以恢复运行。
6. 当资源被释放时，组件需知晓哪些资源是在暂停期间已被释放的。


#### 示例场景：资源抢占导致的组件暂停与恢复
图 3-2、图 3-3 和图 3-4 展示了两个组件（MP3 解码器和 AAC 解码器）竞争同一资源的示例，假设两个组件均需处理一组待解码的压缩缓冲区，具体流程如下：
1. **初始化暂停机制**：IL 客户端设置两个组件支持暂停机制（步骤 1.0 A 和 1.1 A），确保组件在处理流时丢失资源后可恢复。
2. **MP3 解码器获取资源并运行**：
   - IL 客户端将 MP3 解码器转换到空闲状态（步骤 1.2 A）；
   - MP3 解码器向资源管理器（RM）请求 Resource_X（步骤 1.3 A）；
   - RM 批准请求，将 Resource_X 分配给 MP3 解码器（步骤 1.4 A）；
   - MP3 解码器转换到执行状态，开始处理流缓冲区（为简化，图中未显示缓冲区传输）。
3. **AAC 解码器抢占资源**：
   - IL 客户端将 AAC 解码器转换到空闲状态（步骤 1.0 B）；
   - AAC 解码器以更高优先级向 RM 请求 Resource_X（步骤 1.1 B）；
   - RM 向 MP3 解码器发送释放 Resource_X 的请求（步骤 1.2 B）；
   - MP3 解码器 comply 并释放 Resource_X 给 RM（步骤 1.3 B）。
4. **MP3 解码器暂停**：
   - MP3 解码器向 IL 客户端发送错误，表明自身已暂停（步骤 1.4 B）；
   - MP3 解码器向 RM 重新请求 Resource_X（步骤 1.5 B），但因优先级较低，RM 无法立即分配，仅记录该请求；
   - MP3 解码器转换到暂停状态（步骤 1.6 B），并向 IL 客户端发送“暂停命令完成”事件（步骤 1.7 B），此时 MP3 解码器处于“暂停-暂停”状态。
5. **AAC 解码器使用资源并释放**：
   - RM 将 Resource_X 分配给 AAC 解码器（步骤 1.7 B）；
   - AAC 解码器完成到空闲状态的转换，向 IL 客户端发送“命令完成”事件；
   - IL 客户端将 AAC 解码器转换到执行状态，处理若干缓冲区后（步骤 1.0 C），AAC 解码器释放 Resource_X（步骤 1.1 C）。
6. **MP3 解码器恢复运行**：
   - RM 根据此前记录的请求，将 Resource_X 重新分配给 MP3 解码器（步骤 1.2 C）；
   - MP3 解码器将暂停状态设为“恢复”（步骤 1.3 C），并向 IL 客户端发送 `OMX_EventComponentResumed` 事件（步骤 1.4 C）；
   - IL 客户端将 MP3 解码器从暂停状态转换到执行状态，恢复流处理（步骤 1.5 C-1.6 C）。


### 3.1.2.6.4 因动态资源不可用导致的暂停（Suspension Due to Unavailable Dynamic Resources）
在某些场景下，组件资源的大小和类型会在组件生命周期内发生变化。例如，资源需求依赖于数据流本身的属性（需解析数据流后才能知晓），这意味着组件需在执行状态（executing）下完成所有资源的分配（此时本应已分配全部资源）。

#### 处理规则
1. 处于执行状态的组件，可能因处理过程中资源需求增加而尝试分配额外资源（动态资源分配），此过程对客户端完全透明，除非组件在 OMX_StateExecuting 状态下分配资源失败。
2. 若资源分配失败，组件需发送 `OMX_ErrorDynamicResourcesUnavailable` 错误；若 IL 客户端已启用组件的暂停策略，则组件需转换到 OMX_StatePause 状态。
3. 当组件获取到动态资源后，需向 IL 客户端发送 `OMX_EventDynamicResourcesAvailable` 事件，并保持在 OMX_StatePause 状态，直至 IL 客户端将其转换回执行状态以恢复运行。
4. 此场景下的暂停机制与“因资源抢占导致的暂停”基本一致，仅向 IL 客户端报告的错误和事件类型不同。


## 3.1.2.7 OMX_BUFFERHEADERTYPE
在单个端口的场景下，每个数据缓冲区均关联一个缓冲区头（header），该头包含缓冲区的元信息（meta-information）。缓冲区头的共享规则如下：
1. IL 客户端与每个通信端口共享缓冲区头；
2. 每对隧道端口（tunneling ports）共享缓冲区头；
3. 若同一缓冲区在多个端口间传输，则每个端口需关联独立的缓冲区头。

OMX_BUFFERHEADERTYPE 的定义如下：
```c
typedef struct OMX_BUFFERHEADERTYPE
{
  OMX_U32 nSize;
  OMX_VERSIONTYPE nVersion;
  OMX_U8* pBuffer;
  OMX_U32 nAllocLen;
  OMX_U32 nFilledLen;
  OMX_U32 nOffset;
  OMX_PTR pAppPrivate;
  OMX_PTR pPlatformPrivate;
  OMX_PTR pInputPortPrivate;
  OMX_PTR pOutputPortPrivate;
  OMX_HANDLETYPE hMarkTargetComponent;
  OMX_PTR pMarkData;
  OMX_U32 nTickCount;
  OMX_TICKS nTimeStamp;
  OMX_U32 nFlags;
  OMX_U32 nOutputPortIndex;
  OMX_U32 nInputPortIndex;
} OMX_BUFFERHEADERTYPE;
```


### 3.1.2.7.1 参数定义（Parameter Definitions）
- `pBuffer`：指向存储数据的实际缓冲区的指针，但不一定指向有效数据的起始位置（详见下文 `nOffset` 的说明）。
- `nAllocLen`：已分配缓冲区的总大小（以字节为单位），包含有效数据和未使用数据的字节数。
- `nFilledLen`：缓冲区中当前有效数据的总大小（以字节为单位），起始位置由 `pBuffer` 和 `nOffset` 共同指定，包含填充数据（例如，当视频的字节跨度（stride）大于宽度（width）时，视频行末尾的未使用字节）。
- `nOffset`：有效数据相对于缓冲区起始位置的偏移量（以字节为单位），有效数据的起始指针可通过 `pBuffer + nOffset` 计算得出。
- `pAppPrivate`：指向 IL 客户端私有结构的指针。
- `pPlatformPrivate`：指向平台特定私有结构的指针。例如，若 IL 客户端通过平台的内存管理器分配缓冲区，此结构可包含平台内存管理器与该缓冲区关联的信息。
- `pOutputPortPrivate`：使用该缓冲区的输出端口的私有指针。若缓冲区头用于与 IL 客户端通信的输入端口，则 `pOutputPortPrivate` 的值未定义。
- `pInputPortPrivate`：使用该缓冲区的输入端口的私有指针。若缓冲区头用于与 IL 客户端通信的输出端口，则 `pInputPortPrivate` 的值未定义。
- `hMarkTargetComponent`：应在处理此缓冲区时发送 `OMX_EventMark` 事件的组件句柄。若为 NULL 句柄，表明该缓冲区不携带标记。`OMX_CommandMarkBuffer` 命令会将此句柄提供给“标记组件”（marking component），标记组件再将该句柄复制到带标记的缓冲区中。处理缓冲区的每个组件，需将自身句柄与该句柄比对，若匹配则发送标记事件；组件需将输入缓冲区的此字段值传播到关联的输出缓冲区中。
- `pMarkData`：指向与标记关联的 IL 客户端特定数据的指针，该数据会在发送 `OMX_EventMark` 事件时一并传递。IL 客户端收到标记后，可通过此数据区分不同标记。`OMX_CommandMarkBuffer` 命令会将此指针提供给标记组件，标记组件再将该指针复制到带标记的缓冲区中；组件需将输入缓冲区的此字段值传播到关联的输出缓冲区中。
- `nTickCount`：可选字段，组件和 IL 客户端访问组件时可更新为滴答计数（tick count），并非所有组件都会更新此字段。`nTickCount` 的单位为微秒（microseconds），且其值相对于任意起始点，因此无法用于确定绝对时间。
- `nTimeStamp`：与缓冲区中第一个逻辑采样边界（logical sample boundary）对应的时间戳。缓冲区中后续采样的时间戳，可通过“前一个缓冲区的时间戳 + 前一个缓冲区的持续时间”计算得出；组件需将输入缓冲区的此字段值传播到关联的输出缓冲区中。
- `nFlags`：包含缓冲区特定的标志（如 EOS 标志），组件需将输入缓冲区的此字段值传播到关联的输出缓冲区中。支持的标志列表如下：
  ```c
  #define OMX_BUFFERFLAG_EOS 0x00000001
  #define OMX_BUFFERFLAG_STARTTIME 0x00000002
  #define OMX_BUFFERFLAG_DECODEONLY 0x00000004
  #define OMX_BUFFERFLAG_DATACORRUPT 0x00000008
  #define OMX_BUFFERFLAG_ENDOFFRAME 0x00000010
  #define OMX_BUFFERFLAG_SYNCFRAME 0x00000020
  #define OMX_BUFFERFLAG_EXTRADATA 0x00000040
  #define OMX_BUFFERFLAG_CODECCONFIG 0x00000080
  ```
  各标志说明：
  1. **OMX_BUFFERFLAG_EOS**：  
     源组件（如解复用器）在特定输出端口到达流内容末尾时设置此标志，示例场景包括：3GP 文件中的流结束、相机组件（Camera Component）停止在捕获端口（capture port）发送流数据（即支持 `OMX_IndexAutoPauseAfterCapture`）。  
     需注意：发送 `OMX_BUFFERFLAG_EOS` 不排除端口后续响应 IL 客户端命令发送流内容的可能性（例如，3GP 文件接收seek请求到更早位置、相机组件接收命令在捕获端口重新发送内容）；其他组件需根据自身处理逻辑转发此标志；此标志不得响应状态变更命令而发送。
  2. **OMX_BUFFERFLAG_STARTTIME**：  
     流的源组件（如解复用组件）在包含流起始时间戳的缓冲区上设置此标志，起始时间戳对应“启动时”或“seek 操作后”应首先显示的数据。  
     需注意：流的第一个时间戳不一定是起始时间（例如，seek 到视频的某个间帧（interframe）时，流的第一个缓冲区是目标帧之前的内帧（intraframe），起始时间对应目标帧及重建目标帧所需的其他帧）；此标志与缓冲区时间戳直接关联，其与缓冲区数据的关联及传播方式，与时间戳完全一致；收到带此标志的缓冲区的时钟组件客户端，需在其同步端口（sync port）上调用 `OMX_SetConfig`（使用 `OMX_ConfigTimeClientStartTime` 参数），并传递该缓冲区的时间戳。
  3. **OMX_BUFFERFLAG_DECODEONLY**：  
     流的源组件（如解复用组件）在“需解码但无需渲染”的缓冲区上设置此标志，示例场景包括：源组件 seek 到目标间帧时，需解码目标帧之前的帧以重建目标帧，此时源组件会将这些前置帧标记为“仅解码”并发送到下游。  
     需注意：此标志与缓冲区数据关联，其传播方式与缓冲区时间戳完全一致；渲染数据的组件需忽略所有设置了此标志的缓冲区。
  4. **OMX_BUFFERFLAG_DATACORRUPT**：  
     当 IL 客户端识别到缓冲区中的数据已损坏时，设置此标志。
  5. **OMX_BUFFERFLAG_ENDOFFRAME**：  
     可选标志，当缓冲区有效负载（payload）的最后一个字节是帧结束（end-of-frame）时，由输出端口设置。若某个组件在输出端口上实现了此标志的设置逻辑，则该端口发送的所有包含帧结束的缓冲区均需设置此标志；缓冲区有效负载不得包含来自两个不同帧的数据。  
     这些限制可确保：从该输出端口接收数据的输入端口，无需额外处理即可检测帧结束；输入端口可通过第一帧是否包含此标志，轻松判断输出端口是否支持此标志。
  6. **OMX_BUFFERFLAG_SYNCFRAME**：  
     当缓冲区内容包含编码同步帧（coded synchronization frame）时，由输出端口设置。编码同步帧是指无需参考其他帧信息即可重建的帧（例如，MPEG4 I-VOP 视频帧）。若设置此标志，则缓冲区不得包含多个帧。
  7. **OMX_BUFFERFLAG_EXTRADATA**：  
     可选标志，当缓冲区有效负载末尾附加了额外信息时，由输出端口设置。每段额外数据前均需包含一个 `OMX_OTHER_EXTRADATATYPE` 结构，该结构提供额外数据的具体信息。
  8. **OMX_BUFFERFLAG_CODECCONFIG**：  
     可选标志，当缓冲区中的所有字节均为“编解码器特定配置数据”的一部分或全部时，由输出端口设置，示例包括：OMX_VIDEO_CodingAVC 对应的 SPS/PPS NAL 单元、OMX_AUDIO_CodingAAC 对应的 AudioSpecificConfig 数据。  
     需注意：若某个组件为特定流设置此标志，则不得在同一缓冲区中混合“编解码器配置字节”和“帧数据”；所有包含配置字节的缓冲区，需在包含其描述的帧数据的缓冲区之前发送；若某编解码器的流格式要求每个帧开头包含帧特定头部（例如，ADTS 模式下的 OMX_AUDIO_CodingMP3 或 OMX_AUDIO_CodingAAC），则这些头部需作为正常数据处理，不得设置此标志。
- `nOutputPortIndex`：使用该缓冲区的输出端口的端口索引。若缓冲区头用于与 IL 客户端通信的输入端口，则 `nOutputPortIndex` 的值未定义。
- `nInputPortIndex`：使用该缓冲区的输入端口的端口索引。若缓冲区头用于与 IL 客户端通信的输出端口，则 `nInputPortIndex` 的值未定义。


# 3.1.2.8 OMX_PORT_PARAM_TYPE
组件使用 **OMX_PORT_PARAM_TYPE** 结构标识特定领域（domain）端口的数量和起始索引（starting index）。

OMX_PORT_PARAM_TYPE 的定义如下：
```c
typedef struct OMX_PORT_PARAM_TYPE {
  OMX_U32 nSize;
  OMX_VERSIONTYPE nVersion;
  OMX_U32 nPorts;
  OMX_U32 nStartPortNumber;
} OMX_PORT_PARAM_TYPE;
```


## 3.1.2.8.1 参数定义（Parameter Definitions）
- `nPorts`：组件中某一特定端口领域（音频、视频、图像或其他领域）的端口总数。
- `nStartPortNumber`：组件中某一特定端口领域（音频、视频、图像或其他领域）的第一个端口的索引。该领域的后续端口将从 `nStartPortNumber` 开始按顺序编号。


# 3.1.2.9 OMX_CALLBACKTYPE
OpenMAX IL 包含一套回调机制（callback mechanism），支持组件与 IL 客户端之间传递以下信息：
1. IL 客户端触发的异步命令（asynchronous command）已成功完成、执行失败或产生错误。这些命令包括通过 `OMX_SendCommand` 发送的命令，以及 IL 客户端调用 `EmptyThisBuffer` 或 `FillThisBuffer` 所隐含的命令；
2. 发生与 IL 客户端触发命令无关的错误。例如，组件发生不可恢复错误并转换到 OMX_StateInvalid 状态。


## 回调函数组成
为实现回调功能，OpenMAX IL 定义了三个回调函数：
- 通用事件处理器（generic event handler）；
- 两个与数据流相关的回调函数：`EmptyBufferDone` 和 `FillBufferDone`。


## 回调结构的使用流程
IL 客户端需完成以下操作：
1. 在 **OMX_CALLBACKTYPE** 结构中填充其回调入口点（callback entry points）；
2. 在初始化（init）阶段将该结构传递给 OpenMAX IL 核心，通常通过 `OMX_GetHandle` 函数完成。

OMX_CALLBACKTYPE 的定义如下：
```c
typedef struct OMX_CALLBACKTYPE
{
  OMX_ERRORTYPE (*EventHandler)(
    OMX_IN OMX_HANDLETYPE hComponent,
    OMX_IN OMX_PTR pAppData,
    OMX_IN OMX_EVENTTYPE eEvent,
    OMX_IN OMX_U32 nData1,
    OMX_IN OMX_U32 nData2,
    OMX_IN OMX_PTR pEventData);
  
  OMX_ERRORTYPE (*EmptyBufferDone)(
    OMX_IN OMX_HANDLETYPE hComponent,
    OMX_IN OMX_PTR pAppData,
    OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
  
  OMX_ERRORTYPE (*FillBufferDone)(
    OMX_IN OMX_HANDLETYPE hComponent,
    OMX_IN OMX_PTR pAppData,
    OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
} OMX_CALLBACKTYPE;
```


### 3.1.2.9.1 EventHandler
当组件内部发生需要 IL 客户端关注的事件时，组件通过 **EventHandler** 方法通知 IL 客户端。相关说明如下：
- **事件类型**：OpenMAX IL 支持的事件集合由 `OMX_EVENTTYPE` 枚举定义，各事件的含义可参考该枚举的定义；
- **参数含义**：
  - `nData1`：携带已完成的 `OMX_COMMANDTYPE` 命令值或 `OMX_ERRORTYPE` 错误值；
  - `nData2`：携带额外的事件参数（如 `OMX_STATETYPE` 状态值）；
  - `pEventData`：携带事件特定数据（如标记相关数据）；
- **调用特性**：`EventHandler` 是阻塞调用（blocking call），IL 客户端需在 5 毫秒内响应，避免组件长时间阻塞。

EventHandler 方法的定义如下：
```c
OMX_ERRORTYPE(* OMX_CALLBACKTYPE::EventHandler)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_IN OMX_PTR pAppData,
  OMX_IN OMX_EVENTTYPE eEvent,
  OMX_IN OMX_U32 nData1,
  OMX_IN OMX_U32 nData2,
  OMX_IN OMX_PTR pEventData)
```

各事件对应的参数使用规则如表 3-7 所示。

**表 3-7：事件参数使用规则（Event Parameter Usage）**

| 事件（eEvent） | nData1 | nData2 | pEventData |
|----------------|--------|--------|------------|
| OMX_CommandStateSet | 已到达的状态（State reached） | NULL | OMX_EventCmdComplete |
| OMX_CommandFlush | 端口索引（Port index） | NULL | - |
| OMX_CommandPortDisable | 端口索引（Port index） | NULL | - |
| OMX_CommandPortEnable | 端口索引（Port index） | NULL | - |
| OMX_CommandMarkBuffer | 端口索引（Port index） | NULL | - |
| OMX_EventError | 错误码（Error code） | 0 | NULL |
| OMX_EventMark | 0 | 0 | 与标记关联的数据（若有）（Data linked to the mark, if any） |
| OMX_EventPortSettingsChanged | 端口索引（Port index） | 0 | NULL |
| OMX_EventBufferFlag | 端口索引（Port index） | 未修改的 nFlags（nFlags unaltered） | NULL |
| OMX_EventResourcesAcquired | 0 | 0 | NULL |
| OMX_EventDynamicResourcesAvailable | 0 | 0 | NULL |


### 3.1.2.9.2 EmptyBufferDone
组件通过 **EmptyBufferDone** 回调函数，将输入端口的缓冲区归还给 IL 客户端。相关说明如下：
- **缓冲区状态更新**：组件会设置缓冲区头的 `nOffset` 和 `nFilledLen` 值，以反映缓冲区被消耗的部分（例如，若缓冲区被完全消耗，`nFilledLen` 设为 0x0）；
- **调用场景**：除了在执行状态（executing）的组件与 IL 客户端之间的正常数据流中使用外，组件还会在以下场景通过该函数返回输入缓冲区：
  1. IL 客户端指令组件从 OMX_StateExecuting 或 OMX_StatePause 状态转换到 OMX_StateIdle 或 OMX_StateInvalid 状态；
  2. IL 客户端刷新（flush）或禁用（disable）某个端口；
- **调用特性**：`EmptyBufferDone` 是阻塞调用，需在 5 毫秒内返回。因此，IL 客户端可选择不在此调用中填充缓冲区，而是将缓冲区排队（queue），在调用之外处理。

EmptyBufferDone 函数的定义如下：
```c
OMX_ERRORTYPE(* OMX_CALLBACKTYPE::EmptyBufferDone)(
  OMX_OUT OMX_HANDLETYPE hComponent,
  OMX_OUT OMX_PTR pAppData,
  OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer)
```


### 3.1.2.9.3 FillBufferDone
组件通过 **FillBufferDone** 回调函数，将输出端口的缓冲区归还给 IL 客户端。相关说明如下：
- **缓冲区状态更新**：组件会设置缓冲区头的 `nOffset` 和 `nFilledLen` 值，以反映缓冲区被填充的部分（例如，若缓冲区无数据，`nFilledLen` 设为 0x0）；
- **调用场景**：除了在执行状态的组件与 IL 客户端之间的正常数据流中使用外，组件还会在以下场景通过该函数返回输出缓冲区：
  1. IL 客户端指令组件从 OMX_StateExecuting 或 OMX_StatePause 状态转换到 OMX_StateIdle 或 OMX_StateInvalid 状态；
  2. IL 客户端刷新或禁用某个端口；
- **调用特性**：`FillBufferDone` 是阻塞调用，需在 5 毫秒内返回。IL 客户端可选择不在此调用中清空缓冲区，而是将缓冲区排队，在调用之外处理。

FillBufferDone 函数的定义如下：
```c
OMX_ERRORTYPE(* OMX_CALLBACKTYPE::FillBufferDone)(
  OMX_OUT OMX_HANDLETYPE hComponent,
  OMX_OUT OMX_PTR pAppData,
  OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer)
```


# 3.1.2.10 OMX_PARAM_BUFFERSUPPLIERTYPE
**OMX_PARAM_BUFFERSUPPLIERTYPE** 结构用于传递缓冲区提供者（buffer supplier）的设置或偏好。

OMX_PARAM_BUFFERSUPPLIERTYPE 的定义如下：
```c
typedef struct OMX_PARAM_BUFFERSUPPLIERTYPE {
  OMX_U32 nSize;
  OMX_VERSIONTYPE nVersion;
  OMX_U32 nPortIndex;
  OMX_BUFFERSUPPLIERTYPE eBufferSupplier;
} OMX_PARAM_BUFFERSUPPLIERTYPE;
```


## 3.1.2.10.1 参数定义（Parameter Definitions）
- `nPortIndex`：该结构所适用的端口索引。
- `eBufferSupplier`：包含缓冲区提供者的类型索引（输入端口或输出端口）。


# 3.1.2.11 OMX_TUNNELSETUPTYPE
当 IL 客户端通过 `OMX_SetupTunnel` 调用连接两个端口时，`ComponentTunnelRequest` 函数使用 **OMX_TUNNELSETUPTYPE** 结构在这两个端口之间传递数据。

OMX_TUNNELSETUPTYPE 的定义如下：
```c
typedef struct OMX_TUNNELSETUPTYPE {
  OMX_U32 nTunnelFlags;
  OMX_BUFFERSUPPLIERTYPE eSupplier;
} OMX_TUNNELSETUPTYPE;
```


## 3.1.2.11.1 参数定义（Parameter Definitions）
- `nTunnelFlags`：整数参数，包含应用于“接收该结构的端口”的一个或多个位标志（bit flags），支持的标志如下：  
  `#define OMX_PORTTUNNELFLAG_READONLY 0x00000001`  
  若设置此“只读”标志，则接收该结构的输入端口不得修改隧道中提供者端口（supplier port）提供的缓冲区内容。
- `eSupplier`：定义输入端口或输出端口中哪一个是缓冲区提供者。隧道设置的具体调用序列详见 3.4.1.2 节。


# 3.1.2.12 OMX_PARAM_PORTDEFINITIONTYPE
**OMX_PARAM_PORTDEFINITIONTYPE** 结构包含一组通用字段，用于描述组件每个端口的特性。这些字段分为两类：
- 所有领域通用的字段；
- 特定领域专属的字段。

IL 客户端可通过该结构从每个端口获取通用信息。

OMX_PARAM_PORTDEFINITIONTYPE 的定义如下：
```c
typedef struct OMX_PARAM_PORTDEFINITIONTYPE {
  OMX_U32 nSize;
  OMX_VERSIONTYPE nVersion;
  OMX_U32 nPortIndex;
  OMX_DIRTYPE eDir;
  OMX_U32 nBufferCountActual;
  OMX_U32 nBufferCountMin;
  OMX_U32 nBufferSize;
  OMX_BOOL bEnabled;
  OMX_BOOL bPopulated;
  OMX_PORTDOMAINTYPE eDomain;
  union {
    OMX_AUDIO_PORTDEFINITIONTYPE audio;
    OMX_VIDEO_PORTDEFINITIONTYPE video;
    OMX_IMAGE_PORTDEFINITIONTYPE image;
    OMX_OTHER_PORTDEFINITIONTYPE other;
  } format;
  OMX_BOOL bBuffersContiguous;
  OMX_U32 nBufferAlignment;
} OMX_PARAM_PORTDEFINITIONTYPE;
```


## 3.1.2.12.1 参数定义（Parameter Definitions）
- `nPortIndex`：只读字段（read-only），用于标识端口。该值是组件内唯一的 32 位数字：同一组件的两个端口不得共享相同的端口号，但不同组件的端口可使用相同的端口号。
- `eDir`：只读字段，指示端口的方向（`OMX_DirInput` 为输入，`OMX_DirOutput` 为输出）。
- `nBufferCountActual`：表示端口“完成填充（populated）”所需的缓冲区数量（由结构中的 `bPopulated` 字段标识）。组件需为此字段设置不小于 `nBufferCountMin` 的默认值。
- `nBufferCountMin`：只读字段，指定端口所需的最小缓冲区数量。组件需定义一个非零的默认值。
- `nBufferSize`：只读字段，指定为该端口分配的缓冲区的最小字节大小。
- `bEnabled`：只读布尔字段（Boolean），指示端口是否已启用。端口默认值为 `OMX_TRUE`（启用），可通过 `OMX_SendCommand` 方法发送 `OMX_CommandPortEnable` 或 `OMX_CommandPortDisable` 命令启用/禁用端口。端口未启用时，不得进行填充（populated）。
- `bPopulated`：只读布尔字段，指示端口是否已填充。当端口上已分配“数量为 `nBufferCountActual`、大小不小于 `nBufferSize`”的所有缓冲区时，端口处于填充状态。填充状态的端口必须已启用；组件从 OMX_StateLoaded 状态转换到 OMX_StateIdle 状态时，已启用的端口需完成填充；从 OMX_StateIdle 转换到 OMX_StateLoaded 状态时，已启用的端口需取消填充。
- `eDomain`：只读字段，指示端口的领域（domain），该字段决定了下文中 `format` 联合体（union）的内容。
- `format`：领域专属参数的联合体。关于音频、视频、图像和其他领域的参数详情，参见第 4 章“OpenMAX IL 数据 API（OpenMAX IL Data API）”。
- `bBuffersContiguous`：只读布尔字段，指示该端口是否要求每个缓冲区位于连续内存（contiguous memory）中。
- `nBufferAlignment`：只读字段，指定该端口对每个缓冲区的对齐要求（例如，值为 4 表示每个缓冲区需按 4 字节对齐）。值为 0 表示端口无对齐限制。


# 3.1.3 OMX_PORTDOMAINTYPE
表 3-8 列出了 **OMX_PARAM_PORTDEFINITIONTYPE** 结构中用于定义端口领域的字段。

**表 3-8：端口领域名称（Port Domain Names）**

| 字段名称（Field Name） | 描述（Description） |
|------------------------|---------------------|
| OMX_PortDomainAudio | 指定 `format` 字段为 `OMX_AUDIO_PORTDEFINITIONTYPE` 类型的结构 |
| OMX_PortDomainVideo | 指定 `format` 字段为 `OMX_VIDEO_PORTDEFINITIONTYPE` 类型的结构 |
| OMX_PortDomainImage | 指定 `format` 字段为 `OMX_IMAGE_PORTDEFINITIONTYPE` 类型的结构 |
| OMX_PortDomainOther | 指定 `format` 字段为 `OMX_OTHER_PORTDEFINITIONTYPE` 类型的结构 |


# 3.1.4 OMX_HANDLETYPE
**OMX_HANDLETYPE** 结构定义了 IL 客户端可见的组件句柄（component handle），其作用如下：
1. 组件句柄用于访问组件的所有公共方法（public methods）；
2. 组件句柄还包含指向组件私有数据区域（private data area）的指针。

OpenMAX IL 核心在加载组件的过程中，会在组件的协助下分配并初始化组件句柄。组件成功加载后，IL 客户端可安全访问组件的所有公共函数，但部分函数可能因“组件状态不适合当前访问”而返回错误。


# 3.2 OpenMAX IL 核心方法/宏（OpenMAX IL Core Methods/Macros）
OpenMAX IL 核心实现了 IL 客户端使用 OpenMAX IL 组件所需的主接口。为提升效率，OpenMAX IL 定义了一组核心宏（core macros），这些宏与大多数 OpenMAX IL 组件方法形成一对一映射。


## 调用超时规则
部分宏和方法对返回时间有明确要求，具体取决于函数类型：
- **5 毫秒超时**：适用于无需缓冲区处理的命令，标准组织认为这是合理的响应时间；
- **20 毫秒超时**：适用于需完成缓冲区处理的命令，假设最长缓冲区处理时间（如 30 帧/秒视频的单帧处理）小于 30 毫秒，因此 20 毫秒是合理的响应时间。

这些超时时间主要用于组件集成者通过一致性测试（conformance testing）评估组件的响应延迟。


## 核心宏的功能分类
核心宏支持以下操作：
- 获取组件信息（版本、能力）；
- 初始化阶段（init time）设置/获取组件参数；
- 运行阶段（run time）设置/获取组件参数；
- 分配/释放缓冲区；
- 向 OpenMAX IL 组件端口发送满数据缓冲区；
- 向 OpenMAX IL 组件端口发送空缓冲区；
- 向组件发送命令；
- 获取组件的当前状态；
- 获取 OpenMAX IL 组件专有参数的引用。


## 核心方法的功能分类
OpenMAX IL 核心还实现以下方法：
- 初始化/反初始化整个 OpenMAX IL 核心；
- 获取 OpenMAX IL 组件句柄；
- 释放 OpenMAX IL 组件句柄；
- 运行时检测平台上所有可用的 OpenMAX IL 组件；
- 在 OpenMAX IL 组件之间设置数据隧道；
- 获取内容管道（content pipes）；
- 查询已安装的标准组件实现的信息。


## 超时时间的说明
若某方法指定了执行时间限制，该限制并非组件符合标准的强制要求；但如果组件未遵守该限制，需在组件的描述文档中添加说明。


### 3.2.1 函数返回码（Return Codes for the Functions）
表 3-9 列出了每个函数可能返回的所有错误码。其中，“严重错误（critical error）”指组件无法恢复的错误，发生严重错误时，组件应转换到 OMX_StateInvalid 状态。除最右侧两列外，其他列对应组件调用返回的错误；最右侧两列对应组件内部错误触发的异步错误。


### 3.2.2 宏（Macros）
本节介绍 OpenMAX IL 核心宏。需注意：部分宏的调用存在前提条件（例如，仅在隧道模式下调用，或仅在组件状态转换过程中调用）。

表 3-10 定义了“组件处于不同状态时，可调用的宏”。


#### 3.2.2.1 OMX_GetComponentVersion
**OMX_GetComponentVersion** 宏用于查询组件并返回组件相关信息，属于阻塞调用。组件需在 5 毫秒内从该调用返回。

宏的定义如下：
```c
#define OMX_GetComponentVersion (
  hComponent,
  pComponentName,
  pComponentVersion,
  pSpecVersion,
  pComponentUUID)
((OMX_COMPONENTTYPE*)hComponent)->GetComponentVersion( \
  hComponent, \
  pComponentName, \
  pComponentVersion, \
  pSpecVersion,
  pComponentUUID)
```


##### 3.2.2.1.1 方法前提条件（Prerequisites for This Method）
该方法无前提条件。


##### 3.2.2.1.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该宏的调用序列：
```c
/* 检测 IL 客户端与组件的规范版本是否不匹配 */
OMX_GetComponentVersion(
  hComp,
  &CompName,
  &CompVersion,
  &CompSpecVersion);
if (CompSpecVersion != IlClientVersion){
  printf("ERROR: version mismatch\n");
}
```


#### 3.2.2.2 OMX_SendCommand
**OMX_SendCommand** 宏用于向组件发起命令调用，属于非阻塞调用（non-blocking call），需满足以下要求：
1. 至少完成命令参数的验证；
2. 在 5 毫秒内返回。

组件通常在调用上下文之外执行命令，但无线程（threading）的实现方案也可选择在调用上下文内执行。无论哪种方式，组件需在命令完成后通过事件回调（event callback）通知 IL 客户端结果：
- 若命令执行成功，组件生成 `OMX_EventCmdComplete` 回调；
- 若命令执行失败，组件生成 `OMX_EventError` 回调，并传递相应的错误作为参数。

组件可选择将命令排队（queue）以便后续执行，唯一限制是：命令的完成顺序需与请求到达顺序一致。

宏的定义如下：
```c
#define OMX_SendCommand (
  hComponent,
  Cmd,
  nParam,
  pCmdData)
((OMX_COMPONENTTYPE*)hComponent)->SendCommand( \
  hComponent, \
  Cmd, \
  nParam,
  pCmdData)
```

关于每个组件实现的对应函数，详见第 3.3 章“OpenMAX IL 组件方法与结构（OpenMAX IL Component Methods and Structures）”。


#### 3.2.2.3 OMX_CommandStateSet
IL 客户端调用该命令，请求组件转换到 `nParam` 参数指定的状态。组件仅在满足以下条件时，才能成功完成新旧状态的转换：
1. 该转换是合法的（legal transition）；
2. 满足该转换的所有前提条件。

组件状态的详细说明，参见 3.1.1.2 节“OMX_STATETYPE”。

- **转换成功**：组件通过 `OMX_EventCmdComplete` 事件通知 IL 客户端，其中 `nData1` 为 `OMX_CommandStateSet`，`nData2` 为新状态；
- **转换失败**：组件通过 `OMX_EventError` 事件通知 IL 客户端导致失败的错误，相关错误包括但不限于：
  1. `OMX_ErrorSameState`：组件已处于请求的状态；
  2. `OMX_ErrorIncorrectStateTransition`：请求的转换不合法；
  3. `OMX_ErrorInsufficientResources`：转换需分配资源，但组件获取资源失败。


#### 3.2.2.4 OMX_CommandFlush
IL 客户端调用该命令刷新（flush）组件的一个或多个端口，`nParam` 参数指定需刷新的端口索引：
- 若 `nParam` 值为 `OMX_ALL`，组件需刷新所有端口。

不同端口类型的刷新规则如下：
- **非隧道端口（non-tunnelling port）**：端口需通过 `EmptyBufferDone`（输入端口）或 `FillBufferDone`（输出端口）将其持有的所有缓冲区归还给 IL 客户端；
- **隧道端口（tunnelling port）**：被刷新的输入端口需通过 `EmptyThisBuffer`（输入端口）或 `FillThisBuffer`（输出端口）将缓冲区归还给输出端口。

- **刷新成功**：对于每个成功刷新的端口，组件需发送 `OMX_EventCmdComplete` 事件，其中 `nData1` 为 `OMX_CommandFlush`，`nData2` 为该端口的索引（即使 `nParam` 为 `OMX_ALL` 触发的刷新）；
- **刷新失败**：组件通过 `OMX_EventError` 事件通知 IL 客户端错误。


#### 3.2.2.5 OMX_CommandPortDisable
**OMX_CommandPortDisable** 命令用于禁用端口，`nParam` 参数指定需禁用的端口索引：
- 若 `nParam` 值为 `OMX_ALL`，组件需禁用所有端口。


## 禁用端口的特性
- 禁用状态的端口无缓冲区，且不与 IL 客户端或其他端口通过隧道连接；
- 当组件从 OMX_StateLoaded 或 OMX_StateWaitForResources 状态转换到 OMX_StateIdle 状态时，禁用的端口不会分配缓冲区；
- 无论组件处于何种状态，IL 客户端均可通过 `OMX_SetParameter` 修改禁用端口的参数，或在该端口上设置隧道。因此，`OMX_CommandPortDisable` 与 `OMX_CommandPortEnable` 配合使用，可用于端口的动态重新配置（dynamic reconfiguration）或重新隧道化（re-tunneling）。


## 禁用端口的操作流程
1. 端口收到 `OMX_CommandPortDisable` 命令后，需立即在其端口定义结构中清除 `bEnabled` 标志（设为 `OMX_FALSE`）；
2. 根据端口类型执行缓冲区处理：
   - **非提供者端口（non-supplier port）**：IL 客户端需通过以下方式将其持有的缓冲区归还给提供者端口：
     - 隧道模式：调用 `OMX_EmptyThisBuffer`/`OMX_FillThisBuffer`；
     - 非隧道模式：调用 `EmptyBufferDone`/`FillBufferDone`；
     随后，IL 客户端需等待提供者端口通过 `OMX_FreeBuffer` 释放缓冲区，再完成禁用命令；
   - **已分配缓冲区的提供者端口（supplier port）**：IL 客户端需等待非提供者端口通过 `OMX_EmptyThisBuffer` 或 `OMX_FillThisBuffer` 返回所有缓冲区；
     随后，IL 客户端需通过 `OMX_FreeBuffer` 释放缓冲区，再完成禁用命令。


## 禁用结果通知
- **禁用成功**：对于每个成功禁用的端口，组件需发送 `OMX_EventCmdComplete` 事件，其中 `nData1` 为 `OMX_CommandPortDisable`，`nData2` 为该端口的索引（即使 `nParam` 为 `OMX_ALL` 触发的禁用）；
- **禁用失败**：组件通过 `OMX_EventError` 事件通知 IL 客户端错误。


#### 3.2.2.6 OMX_CommandPortEnable
**OMX_CommandPortEnable** 命令用于启用端口，`nParam` 参数指定需启用的端口索引：
- 若 `nParam` 值为 `OMX_ALL`，组件需启用所有端口。


## 启用端口的特性
启用状态的端口需遵守组件当前状态的所有要求，具体规则如下：
| 组件状态 | 端口行为 |
|----------|----------|
| OMX_StateLoaded / OMX_StateWaitForResources | 不分配缓冲区 |
| 其他状态 | 分配所有缓冲区 |
| 从 OMX_StateLoaded / OMX_StateWaitForResources 转换到 OMX_StateIdle | 分配缓冲区 |
| OMX_StateExecuting | 传输缓冲区以支持数据流 |
| 除 OMX_StateLoaded 外的所有状态 | 禁止通过 `OMX_SetParameter` 修改参数 |

`OMX_CommandPortEnable` 与 `OMX_CommandPortDisable` 配合使用，可用于端口的动态重新配置或重新隧道化。


## 启用端口的操作流程
1. 端口收到 `OMX_CommandPortEnable` 命令后，需立即在其端口定义结构中设置 `bEnabled` 标志（设为 `OMX_TRUE`）；
2. 根据组件当前状态执行缓冲区处理：
   - 若组件处于 OMX_StateLoaded 或 OMX_StateWaitForResources 之外的状态，端口需通过“从 OMX_StateLoaded 转换到 OMX_StateIdle”的相同调用序列分配缓冲区；
   - 若组件处于 OMX_StateExecuting 状态，端口需立即开始传输缓冲区。


## 启用结果通知
- **启用成功**：对于每个成功启用的端口，组件需发送 `OMX_EventCmdComplete` 事件，其中 `nData1` 为 `OMX_CommandPortEnable`，`nData2` 为该端口的索引（即使 `nParam` 为 `OMX_ALL` 触发的启用）；
- **启用失败**：组件通过 `OMX_EventError` 事件通知 IL 客户端错误。


#### 3.2.2.7 OMX_CommandMarkBuffer
**OMX_CommandMarkBuffer** 命令用于指令指定端口标记一个缓冲区，参数规则如下：
- `nParam`：存储将执行标记操作的端口索引；
- `OMX_SendCommand` 的 `pCmdData` 参数：指向 **OMX_MARKTYPE** 结构，该结构的 `pMarkTargetComponent` 字段存储“处理完带标记缓冲区后发送事件的组件”的指针，`pMarkData` 字段存储与标记关联的应用特定数据（用于事件中唯一标识该标记）。


## 标记规则
1. **标记对象**：
   - 普通组件（非源组件）：收到标记命令后，标记其后续接收的第一个输入缓冲区；`nParam` 中的端口索引为输入端口索引；
   - 源组件（source component）：收到标记命令后，标记其后续添加到输出缓冲区队列的第一个缓冲区；`nParam` 中的端口索引为输出端口索引。
2. **多标记竞争处理**：以下场景中，多个标记可能竞争同一个缓冲区：
   - 组件收到两个或多个标记命令，且命令之间无缓冲区介入；
   - 两个或多个带标记的输入缓冲区共同生成一个输出缓冲区（如混音器（mixer）场景）；
   - 组件收到标记命令，但下一个缓冲区已被标记。  
   处理规则：组件使用第一个收到的标记标记缓冲区，后续标记按接收顺序应用于后续缓冲区；若无后续缓冲区，组件可在一个或多个空缓冲区上发送剩余标记。


## 标记结果通知
- **标记成功**：对于每个成功标记缓冲区的端口，组件需发送 `OMX_EventCmdComplete` 事件，其中 `nData1` 为 `OMX_CommandMarkBuffer`，`nData2` 为该端口的索引；
- **标记失败**：组件通过 `OMX_EventError` 事件通知 IL 客户端错误。


## 缓冲区标记与传播规则
1. **标记字段复制**：缓冲区头包含 `pMarkTargetComponent` 和 `pMarkData` 字段（含义与 `OMX_MARKTYPE` 中的对应字段一致）。组件通过将标记命令中的这两个字段复制到缓冲区头，完成缓冲区标记；这两个字段默认值为 NULL（标记前）。
2. **标记传播**：组件需按照“缓冲区标志和时间戳的元数据规则”，将输入缓冲区的标记字段传播到输出缓冲区；目标组件（target component）不传播标记，而是将这两个字段清空为 NULL。
3. **标记事件触发**：组件收到缓冲区后，需将自身指针与 `pMarkTargetComponent` 比对；若匹配，组件需在以下时机发送标记事件（含 `pMarkData` 参数）：
   - 缓冲区离开组件后；
   - 若缓冲区不离开组件（如接收器），则在缓冲区处理完成后。


### OMX_MARKTYPE 定义
```c
typedef struct OMX_MARKTYPE {
  OMX_HANDLETYPE hMarkTargetComponent;
  OMX_PTR pMarkData;
} OMX_MARKTYPE;
```


##### 3.2.2.7.1 方法前提条件（Prerequisites for This Method）
该方法无前提条件。


##### 3.2.2.7.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该命令的调用序列：
```c
/* 指令组件端口标记一个缓冲区 */
OMX_MARKTYPE mark;
mark.hMarkTargetComponent = hComp;
mark.pMarkData = appData;
OMX_SendCommand(hComp, OMX_CommandMarkBuffer, portIndex, &mark);
```


# 3.2.2.8 OMX_GetParameter
**OMX_GetParameter** 宏用于从组件中获取参数设置，关键规则如下：
- `nParamIndex` 参数：指定需从组件中获取的结构；
- 调用者职责：需为结构分配内存，并在调用该宏前填充 `nSize` 和 `nVersion` 字段；若参数设置针对端口，还需在调用前在 `nPortIndex` 字段中提供有效的端口号；
- 默认值要求：所有组件需为每个参数提供一组默认值，确保调用者能获取填充有效值的结构；
- 调用特性：阻塞调用（blocking call），组件需在 20 毫秒内从该调用返回。

OMX_GetParameter 宏的定义如下：
```c
#define OMX_GetParameter (
  hComponent,
  nParamIndex,
  pComponentParameterStructure)
((OMX_COMPONENTTYPE*)hComponent)->GetParameter( \
  hComponent, \
  nParamIndex, \
  pComponentParameterStructure)
```

关于每个组件实现的对应函数，详见第 3.3 章“OpenMAX IL 组件方法与结构（OpenMAX IL Component Methods and Structures）”。


## 3.2.2.8.1 方法前提条件（Prerequisites for This Method）
该宏可在组件处于除 **OMX_StateInvalid** 之外的任意状态时调用。


## 3.2.2.8.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该宏的调用序列（禁用组件的所有音频端口）：
```c
/* 禁用组件的所有音频端口 */
OMX_GetParameter(hComp, OMX_IndexParamAudioInit, &oParam);
for (i=0; i<oParam.nPorts; i++) {
  OMX_SendCommand(
    hComp,
    OMX_CommandPortDisable,
    oParam.nStartPortNumber + i,
    0);
}
```


## 3.2.2.8.3 错误条件（Error Conditions）
可能发生的错误条件如下：
- **OMX_ErrorBadParameter**：参数结构的一个或多个字段不正确；
- **OMX_ErrorUnsupportedIndex**：指定的参数索引（parameter index）不受支持；
- **OMX_ErrorVersionMismatch**：参数结构的 `nVersion` 字段与组件预期的版本不匹配；
- **OMX_ErrorNotReady**：`OMX_GetParameter` 操作尚未完成处理，调用者应重试该调用；
- **OMX_ErrorNoMore**：调用 `OMX_GetParameter` 时使用的结构包含 `nPortIndex` 字段，且 `nPortIndex` 的值超过了组件对应领域（appropriate domain）的端口总数。


# 3.2.2.9 OMX_SetParameter
**OMX_SetParameter** 宏用于向组件发送参数结构，关键规则如下：
- `nParamIndex` 参数：指定需传递给组件的结构；
- 调用者职责：需为正确的结构分配内存，并在调用该宏前填充 `nSize`、`nVersion` 字段及所有其他字段；调用后，调用者可释放该结构（组件需复制需保留的所有数据）；
- 只读字段处理：部分参数结构包含只读字段（read-only fields），`OMX_SetParameter` 方法会保留只读字段的值，且调用者尝试修改只读字段时不会生成错误；
- 调用特性：阻塞调用，组件需在 20 毫秒内从该调用返回。

OMX_SetParameter 宏的定义如下：
```c
#define OMX_SetParameter (
  hComponent,
  nParamIndex,
  pComponentParameterStructure)
((OMX_COMPONENTTYPE*)hComponent)->SetParameter( \
  hComponent, \
  nParamIndex, \
  pComponentParameterStructure)
```

关于每个组件实现的对应函数，详见下文 3.3.6 节。


## 3.2.2.9.1 方法前提条件（Prerequisites for This Method）
仅当组件处于 **OMX_StateLoaded** 状态，或针对“已禁用的端口”时，才可调用 **OMX_SetParameter** 宏。


## 3.2.2.9.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该宏的调用序列（强制指定某个端口为缓冲区提供者）：
```c
/* 强制指定某个端口为缓冲区提供者 */
OMX_GetParameter(hComp, OMX_IndexParamPortDefinition, &oPortDef);
if (oPortDef.eDir == OMX_DirInput) {
  oSupplier.eBufferSupplier = OMX_BufferSupplyInput;
} else {
  oSupplier.eBufferSupplier = OMX_BufferSupplyOutput;
}
oSupplier.nPortIndex = nPortIndex;
OMX_SetParameter(hComp, OMX_IndexParamCompBufferSupplier, &oSupplier);
```


## 3.2.2.9.3 错误条件（Error Conditions）
可能发生的错误条件如下：
- **OMX_ErrorIncorrectStateOperation**：调用 `OMX_SetParameter` 时，组件未处于 `OMX_StateLoaded` 状态，或端口未禁用；
- **OMX_ErrorBadParameter**：参数结构的一个或多个字段不正确；
- **OMX_ErrorUnsupportedIndex**：指定的参数索引不受支持；
- **OMX_ErrorVersionMismatch**：参数结构的 `nVersion` 字段与组件预期的版本不匹配；
- **OMX_ErrorUnsupportedSetting**：调用 `OMX_SetParameter` 时，参数结构中的某个字段不受组件支持；
- **OMX_ErrorNotReady**：`OMX_SetParameter` 操作尚未完成处理，调用者应重试该调用；
- **OMX_ErrorNoMore**：调用 `OMX_SetParameter` 时使用的结构包含 `nPortIndex` 字段，且 `nPortIndex` 的值超过了组件对应领域的端口总数。


# 3.2.2.10 OMX_GetConfig
**OMX_GetConfig** 宏用于从组件中获取配置结构，关键规则如下：
- 调用时机：组件加载后，可在任意时间调用；
- `nConfigIndex` 参数：指定需从组件中获取的配置结构；
- 调用者职责：需为结构分配内存，并在调用前填充 `nSize` 和 `nVersion` 字段；若配置设置针对端口，还需在 `nPortIndex` 字段中提供有效的端口号；
- 默认值要求：所有组件需为每个配置提供一组默认值，确保调用者能获取填充有效值的结构；
- 调用特性：阻塞调用，组件需在 5 毫秒内从该调用返回。

OMX_GetConfig 宏的定义如下：
```c
#define OMX_GetConfig (
  hComponent,
  nConfigIndex,
  pComponentConfigStructure)
((OMX_COMPONENTTYPE*)hComponent)->GetConfig( \
  hComponent, \
  nConfigIndex, \
  pComponentConfigStructure)
```

关于每个组件实现的对应函数，详见下文 3.3.7 节。


## 3.2.2.10.1 方法前提条件（Prerequisites for This Method）
该宏可在组件处于除 **OMX_StateInvalid** 之外的任意状态时调用。


## 3.2.2.10.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该宏的调用序列（等待播放位置到达指定时间）：
```c
/* 等待播放位置到达指定时间 */
do {
  OMX_GetConfig(hClockComp, OMX_IndexConfigTimeCurrentMediaTime, &oMediaTime);
} while (oMediaStamp.nTimeStamp < nTargetTimeStamp);
```


## 3.2.2.10.3 错误条件（Error Conditions）
可能发生的错误条件如下：
- **OMX_ErrorBadParameter**：配置结构（config structure）的一个或多个字段不正确；
- **OMX_ErrorUnsupportedIndex**：指定的配置索引（config index）不受支持；
- **OMX_ErrorVersionMismatch**：配置结构的 `nVersion` 字段与组件预期的版本不匹配；
- **OMX_ErrorNotReady**：`OMX_GetConfig` 操作尚未完成处理，调用者应重试该调用；
- **OMX_ErrorNoMore**：调用 `OMX_GetConfig` 时使用的结构包含 `nPortIndex` 字段，且 `nPortIndex` 的值超过了组件对应领域的端口总数。


# 3.2.2.11 OMX_SetConfig
**OMX_SetConfig** 宏用于设置组件的配置值，关键规则如下：
- 调用时机：组件加载后，可在任意时间调用；
- 调用者职责：需为正确的结构分配内存，并在调用前填充 `nSize`、`nVersion` 字段及所有其他字段；调用后，调用者可释放该结构（组件需复制需保留的所有数据）；
- 只读字段处理：部分配置结构包含只读字段，`OMX_SetConfig` 方法会保留这些字段的值，且调用者尝试修改只读字段时不会生成错误；
- 调用特性：阻塞调用，组件需在 5 毫秒内从该调用返回。

OMX_SetConfig 宏的定义如下：
```c
#define OMX_SetConfig (
  hComponent,
  nConfigIndex,
  pComponentConfigStructure )
((OMX_COMPONENTTYPE*)hComponent)->SetConfig( \
  hComponent, \
  nConfigIndex, \
  pComponentConfigStructure)
```

关于每个组件实现的对应函数，详见下文 3.3.8 节。


## 3.2.2.11.1 方法前提条件（Prerequisites for This Method）
该宏可在组件处于除 **OMX_StateInvalid** 之外的任意状态时调用。


## 3.2.2.11.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该宏的调用序列（修改时钟组件的时间缩放比例）：
```c
/* 修改时钟组件的时间缩放比例 */
oScale.xScale = 0x00020000; /* 2 倍速 */
OMX_SetConfig(hClockComp, OMX_IndexConfigTimeScale, (OMX_PTR)&oScale);
```


## 3.2.2.11.3 错误条件（Error Conditions）
可能发生的错误条件如下：
- **OMX_ErrorBadParameter**：配置结构的一个或多个字段不正确；
- **OMX_ErrorUnsupportedIndex**：指定的配置索引不受支持；
- **OMX_ErrorVersionMismatch**：配置结构的 `nVersion` 字段与组件预期的版本不匹配；
- **OMX_ErrorUnsupportedSetting**：调用 `OMX_SetConfig` 时，配置结构中的某个字段不受组件支持；
- **OMX_ErrorNotReady**：`OMX_SetConfig` 操作尚未完成处理，调用者应重试该调用；
- **OMX_ErrorNoMore**：调用 `OMX_SetConfig` 时使用的结构包含 `nPortIndex` 字段，且 `nPortIndex` 的值超过了组件对应领域的端口总数。


# 3.2.2.12 OMX_GetExtensionIndex
**OMX_GetExtensionIndex** 宏用于指令组件将“配置或参数的标准化 OpenMAX IL 扩展字符串”或“厂商自定义扩展字符串”转换为 OpenMAX IL 结构索引，关键规则如下：
- 厂商职责：无需为 `OMX_INDEXTYPE` 枚举中已存在的索引支持该命令（可减少内存占用）；组件可支持 `OMX_INDEXTYPE` 主枚举中未包含的“标准化 OpenMAX IL 扩展索引”或“厂商自定义扩展索引”；
- 调用特性：阻塞调用，组件需在 5 毫秒内从该调用返回。

OMX_GetExtensionIndex 宏的定义如下：
```c
#define OMX_GetExtensionIndex (
  hComponent,
  cParameterName,
  pIndexType )
((OMX_COMPONENTTYPE*)hComponent)->GetExtensionIndex( \
  hComponent, \
  cParameterName, \
  pIndexType)
```

关于每个组件实现的对应函数，详见下文 3.3.9 节。


## 3.2.2.12.1 方法前提条件（Prerequisites for This Method）
该宏可在组件处于除 **OMX_StateInvalid** 之外的任意状态时调用。


## 3.2.2.12.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该宏的调用序列（为读取器设置厂商自定义的文件名参数）：
```c
/* 为读取器组件设置厂商自定义的文件名参数 */
OMX_GetExtensionIndex(
  hFileReaderComp,
  "OMX.CompanyXYZ.index.param.filename",
  &eIndexParamFilename);
OMX_SetParameter(hComp, eIndexParamFilename, &oFileName);
```


# 3.2.2.13 OMX_GetState
**OMX_GetState** 宏用于指令组件获取当前状态，并将状态值存入 `pState` 指向的位置，关键规则：组件需在 5 毫秒内从该调用返回。

OMX_GetState 宏的定义如下：
```c
#define OMX_GetState (
  hComponent,
  pState )
((OMX_COMPONENTTYPE*)hComponent)->GetState( \
  hComponent, \
  pState)
```

关于每个组件实现的对应函数，详见下文 3.3.10 节。


## 3.2.2.13.1 方法前提条件（Prerequisites for This Method）
该方法无前提条件。


## 3.2.2.13.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该宏的调用序列（等待组件转换到 OMX_StateIdle 状态）：
```c
OMX_SendCommand(hComp, OMX_CommandStateSet, OMX_StateIdle, 0);
do {
  OMX_GetState(hComp, &eState);
} while (OMX_StateIdle != eState);
```


# 3.2.2.14 OMX_UseBuffer
**OMX_UseBuffer** 宏用于请求组件使用“IL 客户端已分配的缓冲区”或“隧道组件已提供的缓冲区”，关键规则如下：
- 实现要求：`OMX_UseBuffer` 的实现需分配缓冲区头（buffer header），用输入参数填充缓冲区头，并通过 `ppBufferHdr` 输出参数返回；
- 缓冲区头初始化：组件需正确初始化缓冲区头结构中的 `pInputPortIndex` 和 `pOutputPortIndex` 字段；同时需用 `pAppPrivate` 函数参数初始化 `pAppPrivate` 字段；若在输出端口调用，需用 `pAppPrivate` 初始化 `pInputPortPrivate` 字段；若在输入端口调用，需用 `pAppPrivate` 初始化 `pOutputPortPrivate` 字段；
- 调用条件：需在以下场景之一执行该宏：
  1. 组件处于 `OMX_StateLoaded` 状态，且已发送“转换到 `OMX_StateIdle` 状态”的请求；
  2. 组件处于 `OMX_StateWaitForResources` 状态，所需资源已可用，且组件已准备好转换到 `OMX_StateIdle` 状态；
  3. 组件处于 `OMX_StateExecuting`、`OMX_StatePause` 或 `OMX_StateIdle` 状态，且针对“已禁用的端口”；
- 调用特性：阻塞调用，组件需在 20 毫秒内从该调用返回。

OMX_UseBuffer 宏的定义如下：
```c
#define OMX_UseBuffer(\
  hComponent,\
  ppBufferHdr,\
  nPortIndex,\
  pAppPrivate,\
  nSizeBytes,\
  pBuffer)\
((OMX_COMPONENTTYPE*)hComponent->UseBuffer(\
  hComponent,\
  ppBufferHdr,\
  nPortIndex,\
  pAppPrivate,\
  nSizeBytes,\
  pBuffer)
```

关于每个组件实现的对应函数，详见下文 3.3.12 节。


## 3.2.2.14.1 方法前提条件（Prerequisites for This Method）
组件需处于 `OMX_StateLoaded` 或 `OMX_StateWaitForResources` 状态，或该调用所针对的端口已禁用。


## 3.2.2.14.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该宏的调用序列（提供者端口分配缓冲区并传递给非提供者端口）：
```c
/* 提供者端口分配缓冲区并传递给非提供者端口 */
for (i=0; i<pPort->nBufferCount; i++)
{
  pPort->pBuffer[i] = malloc(pPort->nBufferSize);
  OMX_UseBuffer(pPort->hTunnelComponent,
                &pPort->pBufferHdr[i],
                pPort->nTunnelPort,
                pPort,
                pPort->nBufferSize,
                pPort->pBuffer[i]); /* 原文为 pBuffer[j]，推测为笔误，修正为 pBuffer[i] */
}
```


# 3.2.2.15 OMX_AllocateBuffer
**OMX_AllocateBuffer** 宏用于请求组件分配新的缓冲区和缓冲区头，关键规则如下：
- 实现要求：组件需分配缓冲区和缓冲区头，并返回指向缓冲区头的指针；
- 缓冲区头初始化：与 `OMX_UseBuffer` 一致，需正确初始化 `pInputPortIndex`、`pOutputPortIndex`、`pAppPrivate` 及对应端口私有字段；
- 调用条件：需在以下场景之一执行该宏（与 `OMX_UseBuffer` 相同）：
  1. 组件处于 `OMX_StateLoaded` 状态，且已发送“转换到 `OMX_StateIdle` 状态”的请求；
  2. 组件处于 `OMX_StateWaitForResources` 状态，所需资源已可用，且组件已准备好转换到 `OMX_StateIdle` 状态；
  3. 组件处于 `OMX_StateExecuting`、`OMX_StatePause` 或 `OMX_StateIdle` 状态，且针对“已禁用的端口”；
- 适用范围：仅用于为“与 IL 客户端通信的特定端口”分配缓冲区，不可用于为隧道端口（tunneled ports）分配缓冲区；若在端口配置为隧道模式前已分配缓冲区，组件会拒绝针对该端口的 `OMX_SetupTunnel` 调用；
- 调用特性：阻塞调用，组件需在 5 毫秒内从该调用返回。

OMX_AllocateBuffer 宏的定义如下（原文存在格式冗余，已优化）：
```c
#define OMX_AllocateBuffer (
  hComponent,
  ppBuffer,
  nPortIndex,
  pAppPrivate,
  nSizeBytes )
((OMX_COMPONENTTYPE*)hComponent)->AllocateBuffer( \
  hComponent, \
  ppBuffer, \
  nPortIndex, \
  pAppPrivate, \
  nSizeBytes)
```

关于每个组件实现的对应函数，详见下文 3.3.13 节。


## 3.2.2.15.1 方法前提条件（Prerequisites for This Method）
组件需处于 `OMX_StateLoaded` 或 `OMX_StateWaitForResources` 状态，或该调用所针对的端口已禁用。


## 3.2.2.15.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该宏的调用序列（IL 客户端请求组件分配缓冲区）：
```c
/* IL 客户端请求组件分配缓冲区 */
for (i=0; i<pClient->nBufferCount; i++)
{
  OMX_AllocateBuffer(hComp,
                     &pClient->pBufferHdr[i],
                     pClient->nPortIndex,
                     pClient,
                     pClient->nBufferSize);
}
```


# 3.2.2.16 OMX_FreeBuffer
**OMX_FreeBuffer** 宏用于从组件中释放缓冲区和缓冲区头，关键规则如下：
- 释放逻辑：组件需根据分配情况执行释放操作：
  1. 若仅分配了缓冲区头，则仅释放缓冲区头；
  2. 若同时分配了缓冲区和缓冲区头，则需同时释放两者；
  因此，组件需跟踪自身分配的缓冲区，以执行对应的释放操作；
- 调用条件：需在以下场景之一执行该宏：
  1. 组件处于 `OMX_StateIdle` 状态，且 IL 客户端已发送“转换到 `OMX_StateLoaded` 状态”的请求（例如，组件停止过程中）；
  2. 组件处于 `OMX_StateExecuting`、`OMX_StatePause` 或 `OMX_StateIdle` 状态，且针对“已禁用的端口”；
- 调用注意事项：可在任意时间调用，但若未按上述场景执行，可能导致端口发送 `OMX_ErrorPortUnpopulated` 事件错误；隧道模式下，缓冲区提供者端口需调用该宏，以从其隧道连接的端口释放缓冲区头；
- 调用特性：阻塞调用，组件需在 20 毫秒内从该调用返回。

OMX_FreeBuffer 宏的定义如下（原文存在格式冗余，已优化）：
```c
#define OMX_FreeBuffer (
  hComponent,
  nPortIndex,
  pBuffer )
((OMX_COMPONENTTYPE*)hComponent)->FreeBuffer( \
  hComponent, \
  nPortIndex, \
  pBuffer)
```

关于每个组件实现的对应函数，详见下文 3.3.14 节。


## 3.2.2.16.1 方法前提条件（Prerequisites for This Method）
组件需处于 `OMX_StateIdle` 状态，或该调用所针对的端口已禁用。


## 3.2.2.16.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该宏的调用序列（提供者端口释放缓冲区）：
```c
/* 提供者端口释放缓冲区 */
for (i=0; i<pPort->nBufferCount; i++)
{
  free(pPort->pBuffer[i]);
  pPort->pBuffer[i] = 0;
  OMX_FreeBuffer(pPort->hTunnelComponent,
                 pPort->nTunnelPort,
                 pPort->pBufferHdr[i]);
  pPort->pBufferHdr[i] = 0; /* 原文为 pBufferHdr[j]，推测为笔误，修正为 pBufferHdr[i] */
}
```


# 3.2.2.17 OMX_EmptyThisBuffer
**OMX_EmptyThisBuffer** 宏用于向组件的输入端口发送“已填充数据的缓冲区”，关键规则如下：
- 缓冲区数据标识：若缓冲区包含数据，缓冲区头的 `nFilledLen` 字段值非零；若缓冲区无数据，`nFilledLen` 值为 0x0；
- 调用时机：当组件处于或正在转换到 `OMX_StateExecuting` 或 `OMX_StatePause` 状态时，调用该宏传递含数据的缓冲区；
- 缓冲区返回逻辑：
  1. 非隧道端口：发送到 `OMX_EmptyThisBuffer` 的缓冲区在被清空后，通过 `EmptyBufferDone` 回调返回给 IL 客户端；
  2. 隧道端口：若组件处于 `OMX_StateExecuting` 状态，缓冲区在被清空后发送到隧道端口；若隧道端口被刷新（flush）或禁用（disable），或调用 `OMX_FillThisBuffer` 的组件从 `OMX_StateExecuting`/`OMX_StatePaused` 转换到 `OMX_StateIdle` 状态，缓冲区会返回给提供该缓冲区的输入端口；
- 调用特性：非阻塞调用（non-blocking call），组件会将缓冲区排队并立即返回，缓冲区将在后续合适时机被清空；若缓冲区头的 `nInputPortIndex` 参数未指定有效的输入端口，组件返回 `OMX_ErrorBadPortIndex`；组件需在 5 毫秒内从该调用返回。

OMX_EmptyThisBuffer 宏的定义如下：
```c
#define OMX_EmptyThisBuffer (
  hComponent,
  pBuffer )
((OMX_COMPONENTTYPE*)hComponent)->EmptyThisBuffer( \
  hComponent, \
  pBuffer)
```

关于每个组件实现的对应函数，详见下文 3.3.15 节。


## 3.2.2.17.1 方法前提条件（Prerequisites for This Method）
组件需处于表 3-10 所示的合适状态。


## 3.2.2.17.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该宏的调用序列（传递已填充数据的缓冲区）：
```c
/* 传递已填充数据的缓冲区 */
if (pPort->hTunnelComponent)
  OMX_EmptyThisBuffer(pPort->hTunnelComponent, pBuffer);
else
  pCallbacks->FillBufferDone(hComp, pBuffer, pPort->pCallbackAppData);
```


# 3.2.2.18 OMX_FillThisBuffer
**OMX_FillThisBuffer** 宏用于向组件的输出端口发送“空缓冲区”，关键规则如下：
- 调用时机：当组件处于或正在转换到 `OMX_StateExecuting` 或 `OMX_StatePaused` 状态时，调用该宏传递空缓冲区；
- 缓冲区返回逻辑：
  1. 非隧道端口：发送到 `OMX_FillThisBuffer` 的缓冲区在被填充后，通过 `FillBufferDone` 回调返回给 IL 客户端；
  2. 隧道端口：若组件处于 `OMX_StateExecuting` 状态，缓冲区在被填充后发送到隧道端口；若隧道端口被刷新或禁用，或调用 `OMX_FillThisBuffer` 的组件从 `OMX_StateExecuting`/`OMX_StatePaused` 转换到 `OMX_StateIdle` 状态，缓冲区会返回给提供该缓冲区的输出端口；
- 调用特性：非阻塞调用，组件会将缓冲区排队并立即返回，缓冲区将在后续合适时机被填充；若缓冲区头的 `nOutputPortIndex` 参数未指定有效的输出端口，组件返回 `OMX_ErrorBadPortIndex`；组件需在 5 毫秒内从该调用返回。

OMX_FillThisBuffer 宏的定义如下：
```c
#define OMX_FillThisBuffer (
  hComponent,
  pBuffer )
((OMX_COMPONENTTYPE*)hComponent)->FillThisBuffer( \
  hComponent, \
  pBuffer)
```

关于每个组件实现的对应函数，详见下文 3.3.16 节。


## 3.2.2.18.1 方法前提条件（Prerequisites for This Method）
组件需处于表 3-10 所示的合适状态。


## 3.2.2.18.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该宏的调用序列（端口启用时，向提供者端口传递缓冲区）：
```c
/* 端口启用时，若为隧道模式、输入端口且非提供者，则向提供者端口传递缓冲区 */
if (pPort->hTunnelComponent &&
    (pPort->oPortDef.eDir == OMX_DirInput) &&
    (pPort->eSupplierSetting == OMX_BufferSupplyInput) )
{
  for (i=0; i<pPort->nBuffers; i++){
    OMX_FillThisBuffer(pPort->hTunnelComponent,
                       pPort->ppBufferHdrs[i]);
  }
}
```


# 3.2.2.19 OMX_UseEGLImage
**OMX_UseEGLImage** 用于使 OpenMAX IL 组件将“通过 EGL 已分配的图像”作为缓冲区使用，关键规则如下：
- EGLImage 特性：EGLImage 设计用于在基于渲染的 EGL 接口（如 OpenGL ES、OpenVG）之间共享数据；其格式对 EGL 客户端是透明的（opaque），因此通过该宏分配的内存无法被 IL 客户端直接访问；
- 组件实现要求：组件需提供该接口的方法，但可通过返回 `OMX_ErrorNotImplemented` 表示未实现；组件需检查传入的 EGLImage，判断其是否与端口配置兼容；
- 功能替代：该宏用于请求组件使用 EGL 提供的 EGLImage，替代 `OMX_UseBuffer` 方法；其实现需分配缓冲区头，用输入参数填充，并通过 `ppBufferHdr` 输出参数返回；
- 特殊限制：`pBufferHdr` 参数的 `pBuffer` 字段需设为 0x0（因 EGLImage 格式对 IL 客户端透明）；
- 调用条件：与 `OMX_UseBuffer` 相同（组件处于 `OMX_StateLoaded`/`OMX_StateWaitForResources` 状态，或针对已禁用端口）；
- 调用特性：阻塞调用，组件需在 20 毫秒内从该调用返回。

OMX_UseEGLImage 宏的定义如下：
```c
#define OMX_UseEGLImage(\
  hComponent,\
  ppBufferHdr,\
  nPortIndex,\
  pAppPrivate,\
  eglImage)\
((OMX_COMPONENTTYPE*)hComponent->UseEGLImage(\
  hComponent,\
  ppBufferHdr,\
  nPortIndex,\
  pAppPrivate,\
  eglImage)
```

关于每个组件实现的对应函数，详见下文 3.3.19 节。


## 3.2.2.19.1 方法前提条件（Prerequisites for This Method）
组件需处于 `OMX_StateLoaded` 或 `OMX_StateWaitForResources` 状态，或该调用所针对的端口已禁用。


# 3.2.3 函数（Functions）
本节介绍 OpenMAX IL API 中的函数。


## 3.2.3.1 OMX_Init
**OMX_Init** 方法用于初始化 OpenMAX IL 核心，关键规则如下：
- 调用顺序：`OMX_Init` 必须是 OpenMAX IL 中的第一个调用，且在未调用 `OMX_Deinit` 的情况下仅能执行一次；
- 重复调用处理：若调用两次 `OMX_Init`，会返回 `OMX_ErrorNone`，但第二次初始化请求会被忽略；
- 调用特性：核心需在 20 毫秒内从该调用返回。

OMX_Init 的使用方式如下：
```c
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init()
```


### 3.2.3.1.1 方法前提条件（Prerequisites for This Method）
该方法无前提条件。


### 3.2.3.1.2 方法结果/输出（Results/Outputs for This Method）
- 若命令执行成功，返回码为 `OMX_ErrorNone`；
- 若执行失败，返回对应的 OpenMAX IL 错误；
- 该函数执行成功后，OpenMAX IL 核心函数可正常使用。


### 3.2.3.1.3 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该函数的调用序列（初始化 OpenMAX IL 并创建组件）：
```c
/* 初始化 OpenMAX IL 并创建组件 */
OMX_Init();
OMX_GetHandle(hMp3Decoder, "OMX.CompanyXYZ.mp3.decoder", pAppData, pCallbacks);
OMX_GetHandle(hAudioMixer, "OMX.CompanyXYZ.audio.mixer", pAppData, pCallbacks);
```


## 3.2.3.2 OMX_Deinit
**OMX_Deinit** 方法用于反初始化 OpenMAX IL 核心，关键规则如下：
- 调用时机：`OMX_Deinit` 必须是 OpenMAX IL 核心的最后一个调用，且需在释放所有与 OpenMAX IL 相关的资源后执行；
- 调用特性：核心需在 20 毫秒内从该调用返回；尽管理想情况下核心应指令所有组件返回加载状态（loaded state）后再反初始化，但这可能超出推荐的调用时间，且需核心跟踪所有组件句柄（可能增加部分平台的复杂度）。

OMX_Deinit 的使用方式如下：
```c
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit()
```


### 3.2.3.2.1 方法前提条件（Prerequisites for This Method）
调用 `OMX_Deinit` 前，需释放 IL 客户端获取的所有组件句柄，即释放与组件关联的所有资源。


### 3.2.3.2.2 方法结果/输出（Results/Outputs for This Method）
- `OMX_Deinit` 返回 `OMX_ERRORTYPE` 类型；
- 若命令执行成功，返回码为 `OMX_ErrorNone`；
- 若执行失败，返回对应的 OpenMAX IL 错误。


### 3.2.3.2.3 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该函数的调用序列（检查特定名称的组件是否存在）：
```c
/* 检查特定名称的组件是否存在 */
OMX_Init();
eError = OMX_ErrorNone;
for (i=0; OMX_ErrorNone == eError; i++)
{
  eError = OMX_ComponentNameEnum(szCompEnumName, 256, i);
  if ((OMX_ErrorNone == eError) && (!strcmp(szCompEnumName, szComponentName)))
  {
    OMX_Deinit();
    return OMX_TRUE;
  }
}
OMX_Deinit();
return OMX_FALSE;
```


## 3.2.3.3 OMX_ComponentNameEnum
**OMX_ComponentNameEnum** 方法用于枚举系统中所有已识别组件的名称，以在运行时检测系统中的所有组件，关键规则如下：
- 枚举顺序：组件名称的枚举无严格顺序，但每个名称仅枚举一次；
- 动态组件检测：若 OpenMAX IL 核心支持运行时安装新组件，仅在第一次调用“枚举组件名称”（即 `nIndex` 值为 0x0）时，才需检测新安装的组件。

OMX_ComponentNameEnum 方法的定义如下：
```c
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
  OMX_OUT OMX_STRING cComponentName,
  OMX_IN OMX_U32 nNameLength,
  OMX_IN OMX_U32 nIndex
)
```


### 3.2.3.3.1 方法前提条件（Prerequisites for This Method）
需在调用 `OMX_Init` 函数后，方可调用 `OMX_ComponentNameEnum`。


### 3.2.3.3.2 方法结果/输出（Results/Outputs for This Method）
- 若 `OMX_ComponentNameEnum` 执行成功，返回码为 `OMX_ErrorNone`；
- 若 `nIndex` 值超过“系统中组件总数 - 1”，返回 `OMX_ErrorNoMore`；
- 若执行失败，返回对应的 OpenMAX IL 错误。


### 3.2.3.3.3 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该函数的调用序列（打印所有组件列表）：
```c
/* 打印所有组件列表 */
eError = OMX_ErrorNone;
for (i=0; OMX_ErrorNoMore != eError; i++)
{
  eError = OMX_ComponentNameEnum(szCompName, 256, i);
  if (OMX_ErrorNone == eError)
    printf("Component %i: %s\n", i, szCompName); /* 原文缺少 i，补充以正确打印组件序号 */
}
```


## 3.2.3.4 OMX_GetHandle
**OMX_GetHandle** 方法用于执行以下操作：
1. 定位由“组件名称”指定的组件；
2. 将该组件加载到内存并验证；
3. 若组件有效，调用组件的方法填充组件句柄，并设置回调；
4. 分配实际的 `OMX_HANDLETYPE` 结构，确保其正确填充，然后用指向“新创建句柄”的指针更新 `*pHandle` 的值。

关键规则如下：
- 调用特性：组件需在 20 毫秒内从该调用返回；
- 实例创建：每次 `OMX_GetHandle` 函数执行成功，都会创建一个新的组件实例；新创建的组件处于 `OMX_StateLoaded` 状态，IL 客户端需先配置该组件，方可使用；
- 命名规范：组件通过名称请求，因此定义了统一命名格式：`“OMX.<厂商名称>.<厂商自定义规则>”`，示例：`OMX.CompanyABC.MP3Decoder.productXYZ`；不同厂商的组件名称无需标准化。

OMX_GetHandle 的定义如下：
```c
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
  OMX_OUT OMX_HANDLETYPE * pHandle,
  OMX_IN OMX_STRING cComponentName,
  OMX_IN OMX_PTR pAppData,
  OMX_IN OMX_CALLBACKTYPE * pCallbacks
)
```


### 3.2.3.4.1 方法前提条件（Prerequisites for This Method）
OpenMAX IL 核心必须已初始化。


### 3.2.3.4.2 方法结果/输出（Results/Outputs for This Method）
若执行成功，函数会向 IL 客户端返回有效的组件句柄。


### 3.2.3.4.3 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该函数的调用序列（确定组件的最大实例化数量）：
```c
/* 确定组件的最大实例化数量 */
eError = OMX_ErrorNone;
for (i=0; OMX_ErrorNone == eError; i++)
{
  eError = OMX_GetHandle(&hComp[i],
                         szComponentName,
                         pAppData,
                         pCallbacks);
}
printf("Created %i instantiations.\n", i);
```


## 3.2.3.5 OMX_FreeHandle
**OMX_FreeHandle** 方法用于释放由 `OMX_GetHandle` 方法分配的句柄，关键规则如下：
- 调用特性：组件需在 20 毫秒内从该调用返回；
- 调用限制：IL 客户端仅应在组件处于 `OMX_StateLoaded` 或 `OMX_StateInvalid` 状态时调用 `OMX_FreeHandle`；在其他状态调用可能导致组件执行时间超过推荐的 20 毫秒，该场景仅作为故障恢复机制提供。

OMX_FreeHandle 的定义如下：
```c
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
  OMX_IN OMX_HANDLETYPE hComponent
)
```


### 3.2.3.5.1 方法前提条件（Prerequisites for This Method）
调用该方法时，组件需处于 `OMX_StateLoaded` 或 `OMX_StateInvalid` 状态。


### 3.2.3.5.2 方法结果/输出（Results/Outputs for This Method）
与该组件关联的所有资源都会被释放。


### 3.2.3.5.3 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该函数的调用序列（停止执行中组件并清理）：
```c
/* 停止执行中组件并清理组件 */
OMX_SendCommand(hComp, OMX_CommandStateSet, OMX_StateIdle, 0);
OMX_SendCommand(hComp, OMX_CommandStateSet, OMX_StateLoaded, 0);
do {
  OMX_GetState(hComp, &eState);
} while (OMX_StateLoaded != eState);
OMX_FreeHandle(hComp);
```


## 3.2.3.6 OMX_SetupTunnel
**OMX_SetupTunnel** 方法用于在输出端口和输入端口之间设置隧道通信（tunneled communication），关键规则如下：
- 方法属性：该方法是实际方法，而非定义的宏；其会调用组件的 `ComponentTunnelRequest()` 方法来设置隧道；
- 非隧道模式配置：
  1. 若需将输入端口改为非隧道通信，`hOutput` 参数值需设为 0x0；
  2. 若需将输出端口改为非隧道通信，`hInput` 参数值需设为 0x0；
- 隧道模式配置流程：
  1. 首先调用“输出端口所属组件”的 `ComponentTunnelRequest()`；
  2. 若第一步成功，再调用“输入端口所属组件”的 `ComponentTunnelRequest()`；
  3. 若任意一步 `ComponentTunnelRequest()` 失败，该方法会将输出端口和输入端口均配置为非隧道通信；
- 专有通信协商：只要输出端口和输入端口均支持专有通信（proprietary communication），组件可协商使用专有通信替代隧道通信；IL 客户端无法区分隧道通信和专有通信；
- 调用特性：核心需在 20 毫秒内从该调用返回；
- 配置限制：
  1. IL 客户端可使用 `OMX_SetupTunnel` 在基础配置文件组件（base profile components）之间建立专有通信（需两者均支持），但不可建立隧道；仅可在互操作配置文件组件（Interop profile components）之间建立隧道；
  2. 错误返回规则：
     - 若因 `OMX_SetupTunnel` 实现既不支持隧道也不支持专有通信导致失败，返回 `OMX_ErrorNotImplemented`；
     - 若因 `OMX_SetupTunnel` 支持专有通信但不支持隧道，且专有通信不适用于给定组件导致失败，返回 `OMX_ErrorTunnelingUnsupported`；
     - 仅当操作对象包含基础配置文件组件时，才可能返回上述两种错误；操作两个互操作配置文件组件时，不适用这两种错误。

关于两个组件之间设置数据隧道的详细流程，详见 3.4.1.2 节。

OMX_SetupTunnel 的定义如下：
```c
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
  OMX_IN OMX_HANDLETYPE hOutput,
  OMX_IN OMX_U32 nPortOutput,
  OMX_IN OMX_HANDLETYPE hInput,
  OMX_IN OMX_U32 nPortInput
)
```


### 3.2.3.6.1 方法前提条件（Prerequisites for This Method）
参与隧道通信的每个组件需处于 `OMX_StateLoaded` 状态，或其端口已禁用。


### 3.2.3.6.2 方法结果/输出（Results/Outputs for This Method）
- 若同时提供输出组件和输入组件，且方法执行成功，则在指定的输出端口和输入端口之间建立了隧道通信或专有通信；
- 若仅提供输出组件或输入组件，或处理过程中发生错误，则端口会被配置为非隧道通信。


### 3.2.3.6.3 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该函数的调用序列（在两个组件间设置隧道，然后转换到空闲状态）：
```c
/* 在两个组件间设置隧道，然后转换到空闲状态 */
OMX_SetupTunnel(hCompA, nCompAOutPort, hCompB, nCompBInPort);
OMX_SendCommand(hCompA, OMX_CommandStateSet, OMX_StateIdle, 0);
OMX_SendCommand(hCompB, OMX_CommandStateSet, OMX_StateIdle, 0);
```


## 3.2.3.7 OMX_GetContentPipe
**OMX_GetContentPipe** 方法用于返回“能够操作指定内容（通过 URI 指定）的内容管道（content pipe）”，关键规则如下：
- 核心职责：OpenMAX IL 核心需提供该接口；若未实现，返回 `OMX_ErrorNotImplemented`；
- 调用者权限：IL 客户端也可使用该函数获取内容管道供自身使用；
- 调用特性：核心需在 20 毫秒内从该调用返回。

OMX_GetContentPipe 的定义如下（修正原文格式错误）：
```c
OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetContentPipe (
  OMX_OUT OMX_HANDLETYPE *hPipe,
  OMX_IN OMX_STRING szURI
)
```


### 3.2.3.7.1 方法前提条件（Prerequisites for This Method）
无前提条件。


### 3.2.3.7.2 方法结果/输出（Results/Outputs for This Method）
IL 核心会在 `hPipe` 字段中填充与给定 URI 对应的内容管道句柄。


# 3.3 OpenMAX IL 组件方法与结构（OpenMAX IL Component Methods and Structures）
OpenMAX IL 组件在 `OMX_Component.h` 头文件中定义，**OMX_COMPONENTTYPE** 结构包含组件的数据字段和函数入口点。


## 3.3.1 pComponentPrivate
`pComponentPrivate` 是指向组件私有数据区域（component private data area）的指针，特性如下：
- 组件首次加载时，由组件自行分配并初始化此字段；
- 应用程序（application）不得访问该数据区域。


## 3.3.2 pApplicationPrivate
`pApplicationPrivate` 是指向应用程序私有数据区域（application private data area）的指针，特性如下：
- 组件在 `SetCallbacks` 调用期间初始化此字段；
- 当组件触发回调（callbacks）时，此字段会回传给 IL 客户端。


## 3.3.3 GetComponentVersion
IL 客户端通过 **OMX_GetComponentVersion** 核心宏调用组件的 `GetComponentVersion` 方法。该方法的语义说明详见上文 3.2.2.1 节中 `OMX_GetComponentVersion` 的定义。

GetComponentVersion 的定义如下：
```c
OMX_ERRORTYPE (*GetComponentVersion)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_OUT OMX_STRING pComponentName,
  OMX_OUT OMX_VERSIONTYPE* pComponentVersion,
  OMX_OUT OMX_VERSIONTYPE* pSpecVersion);
```


## 3.3.4 SendCommand
IL 客户端通过 **OMX_SendCommand** 核心宏调用组件的 `SendCommand` 方法。该方法的语义说明详见上文 3.2.2.2 节中 `OMX_SendCommand` 的定义。

SendCommand 的定义如下：
```c
OMX_ERRORTYPE (*SendCommand)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_IN OMX_COMMANDTYPE Cmd,
  OMX_IN OMX_U32 nParam,
  OMX_IN OMX_PTR pCmdData);
```


## 3.3.5 GetParameter
IL 客户端或隧道组件（tunneled component）通过 **OMX_GetParameter** 核心宏调用组件的 `GetParameter` 方法。该方法的语义说明详见上文 3.2.2.8 节中 `OMX_GetParameter` 的定义。

GetParameter 的定义如下：
```c
OMX_ERRORTYPE (*GetParameter)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_IN OMX_INDEXTYPE nParamIndex,
  OMX_INOUT OMX_PTR pComponentParameterStructure);
```


## 3.3.6 SetParameter
IL 客户端或隧道组件通过 **OMX_SetParameter** 核心宏调用组件的 `SetParameter` 方法。该方法的语义说明详见上文 3.2.2.8.3 节中 `OMX_SetParameter` 的定义。

SetParameter 的定义如下：
```c
OMX_ERRORTYPE (*SetParameter)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_IN OMX_INDEXTYPE nIndex,
  OMX_IN OMX_PTR pComponentParameterStructure);
```


## 3.3.7 GetConfig
IL 客户端通过 **OMX_GetConfig** 核心宏调用组件的 `GetConfig` 方法。该方法的语义说明详见上文 3.2.2.9.3 节中 `OMX_GetConfig` 的定义。

GetConfig 的定义如下：
```c
OMX_ERRORTYPE (*GetConfig)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_IN OMX_INDEXTYPE nIndex,
  OMX_INOUT OMX_PTR pComponentConfigStructure);
```


## 3.3.8 SetConfig
IL 客户端通过 **OMX_SetConfig** 核心宏调用组件的 `SetConfig` 方法。该方法的语义说明详见上文 3.2.2.10.3 节中 `OMX_SetConfig` 的定义。

SetConfig 的定义如下：
```c
OMX_ERRORTYPE (*SetConfig)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_IN OMX_INDEXTYPE nIndex,
  OMX_IN OMX_PTR pComponentConfigStructure);
```


## 3.3.9 GetExtensionIndex
IL 客户端通过 **OMX_GetExtensionIndex** 核心宏调用组件的 `GetExtensionIndex` 方法（原文“GetExtenstionIndex”为拼写错误，修正为“GetExtensionIndex”）。该方法的语义说明详见上文 3.2.2.12 节中 `OMX_GetExtensionIndex` 的定义（原文“section 3.2.2.1293”为编号错误，修正为“section 3.2.2.12”）。

GetExtensionIndex 的定义如下：
```c
OMX_ERRORTYPE (*GetExtensionIndex)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_IN OMX_STRING cParameterName,
  OMX_OUT OMX_INDEXTYPE* pIndexType);
```


## 3.3.10 GetState
IL 客户端通过 **OMX_GetState** 核心宏调用组件的 `GetState` 方法。该方法的语义说明详见上文 3.2.2.13 节中 `OMX_GetState` 的定义。

GetState 的定义如下：
```c
OMX_ERRORTYPE (*GetState)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_OUT OMX_STATETYPE* pState);
```


## 3.3.11 ComponentTunnelRequest
`ComponentTunnelRequest` 方法用于与另一个 OpenMAX IL 组件交互，以完成以下操作：
1. 判定隧道通信（tunneling）是否可行；
2. 若可行，则设置隧道通信。

该方法的返回码可用于判断：隧道通信不可行、使用专有通信（proprietary communication）或使用隧道通信。

### 核心规则
1. **互操作配置文件组件（Interop Profile Component）**：必须支持与“参数兼容的组件”进行隧道通信，也可额外支持专有通信；
2. **专有通信协商**：若组件支持专有通信，协商过程由厂商自定义，但需返回正确结果，具体配置细节由厂商组件实现者决定；
3. **调用逻辑**：支持隧道通信的两个组件均需调用此方法，不同端口类型的调用行为不同：
   - **输出端口所属组件**：调用时需在 `pTunnelSetup` 中指定其提供者偏好（supplier preference）；
   - **输入端口所属组件**：调用时需完成两项操作：
     1. 通过一次或多次 `GetParameter` 调用检查端口间的数据兼容性；
     2. 查看输出端口的缓冲区提供者偏好，并通过 `OMX_SetParameter`（索引为 `OMX_IndexParamCompBufferSupplier`）告知输出端口“哪个端口是缓冲区提供者”；
4. **非隧道模式配置**：若 `pTunnelComp` 参数为 NULL，需将该端口配置为与 IL 客户端进行非隧道通信；
5. **调用特性**：组件需在 5 毫秒内从该调用返回。

ComponentTunnelRequest 的定义如下：
```c
OMX_ERRORTYPE (*ComponentTunnelRequest)(
  OMX_IN OMX_HANDLETYPE hComp,
  OMX_IN OMX_U32 nPort,
  OMX_IN OMX_HANDLETYPE hTunneledComp,
  OMX_IN OMX_U32 nTunneledPort,
  OMX_INOUT OMX_TUNNELSETUPTYPE* pTunnelSetup);
```


### 3.3.11.1 方法前提条件（Prerequisites for This Method）
组件需处于 **OMX_StateLoaded** 状态。


### 3.3.11.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该方法的调用序列（将 `SetupTunnel` 调用转换为两次 `ComponentTunnelRequest` 调用）：
```c
/* 将 SetupTunnel 调用转换为两次 ComponentTunnelRequest 调用 */
pCompOut = (OMX_COMPONENTTYPE *)hOutput;
pCompIn = (OMX_COMPONENTTYPE *)hInput;
pCompOut->ComponentTunnelRequest(hOutput, nPortOutput, hInput, nPortInput, &oTunnelSetup);
pCompIn->ComponentTunnelRequest(hInput, nPortInput, hOutput, nPortOutput, &oTunnelSetup);
```


## 3.3.12 UseBuffer
IL 客户端或隧道组件通过 **OMX_UseBuffer** 核心宏调用组件的 `UseBuffer` 方法。该方法的语义说明详见上文 3.2.2.14 节中 `OMX_UseBuffer` 的定义。

UseBuffer 的定义如下：
```c
OMX_ERRORTYPE (*UseBuffer)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
  OMX_IN OMX_U32 nPortIndex,
  OMX_IN OMX_PTR pAppPrivate,
  OMX_IN OMX_U32 nSizeBytes,
  OMX_IN OMX_U8* pBuffer);
```


## 3.3.13 AllocateBuffer
IL 客户端通过 **OMX_AllocateBuffer** 核心宏调用组件的 `AllocateBuffer` 方法。该方法的语义说明详见上文 3.2.2.15 节中 `OMX_AllocateBuffer` 的定义。

AllocateBuffer 的定义如下：
```c
OMX_ERRORTYPE (*AllocateBuffer)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_INOUT OMX_BUFFERHEADERTYPE** pBuffer,
  OMX_IN OMX_U32 nPortIndex,
  OMX_IN OMX_PTR pAppPrivate,
  OMX_IN OMX_U32 nSizeBytes);
```


## 3.3.14 FreeBuffer
IL 客户端或隧道组件通过 **OMX_FreeBuffer** 核心宏调用组件的 `FreeBuffer` 方法。该方法的语义说明详见上文 3.2.2.16 节中 `OMX_FreeBuffer` 的定义。

FreeBuffer 的定义如下：
```c
OMX_ERRORTYPE (*FreeBuffer)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_IN OMX_U32 nPortIndex,
  OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
```


## 3.3.15 EmptyThisBuffer
IL 客户端或隧道组件通过 **OMX_EmptyThisBuffer** 核心宏调用组件的 `EmptyThisBuffer` 方法。该方法的语义说明详见上文 3.2.2.17 节中 `OMX_EmptyThisBuffer` 的定义。

EmptyThisBuffer 的定义如下：
```c
OMX_ERRORTYPE (*EmptyThisBuffer)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
```


## 3.3.16 FillThisBuffer
IL 客户端或隧道组件通过 **OMX_FillThisBuffer** 核心宏调用组件的 `FillThisBuffer` 方法。该方法的语义说明详见上文 3.2.2.18 节中 `OMX_FillThisBuffer` 的定义。

FillThisBuffer 的定义如下：
```c
OMX_ERRORTYPE (*FillThisBuffer)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
```


## 3.3.17 SetCallbacks
`SetCallbacks` 方法用于让核心（core）将“来自 IL 客户端的回调结构”传递给组件，特性如下：
- 调用类型：阻塞调用（blocking call）；
- 返回要求：组件需在 5 毫秒内从该调用返回。

SetCallbacks 的定义如下：
```c
OMX_ERRORTYPE (*SetCallbacks)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_IN OMX_CALLBACKTYPE* pCallbacks,
  OMX_IN OMX_PTR pAppData);
```


### 3.3.17.1 方法前提条件（Prerequisites for This Method）
组件需处于 **OMX_StateLoaded** 状态。


### 3.3.17.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该方法的调用序列（`GetHandle` 过程中为静态链接组件创建、初始化并设置回调）：
```c
/* GetHandle 过程（针对静态链接组件）：创建组件、初始化并设置回调 */
pComp = (OMX_COMPONENTTYPE *)malloc(sizeof(OMX_COMPONENTTYPE));
hHandle = (OMX_HANDLETYPE)pComp;
pComp->nVersion = version_1_0;  /* 假设 version_1_0 为预定义的 1.0 版本变量 */
pComp->nSize = sizeof(OMX_COMPONENTTYPE);
OMX_ComponentRegistered[i].pInitialize(hHandle);
pComp->SetCallbacks(hHandle, pCallBacks, pAppData);
```


## 3.3.18 ComponentDeinit
当核心需要销毁（dispose of）组件时，会调用 `ComponentDeinit` 函数。

ComponentDeinit 的定义如下：
```c
OMX_ERRORTYPE (*ComponentDeinit)(
  OMX_IN OMX_HANDLETYPE hComponent);
```


### 3.3.18.1 方法前提条件（Prerequisites for This Method）
该方法无前提条件：无论组件处于何种状态，IL 客户端均可执行此函数，以确保即使组件对状态变更无响应，也能完成反初始化。但为了正常关闭，建议在组件处于 **OMX_StateLoaded** 状态时执行 `ComponentDeinit`。


### 3.3.18.2 调用序列示例代码（Sample Code Showing Calling Sequence）
以下示例代码展示了该方法的调用序列（`FreeHandle` 过程中反初始化并销毁组件）：
```c
/* FreeHandle 过程：反初始化组件并销毁 */
pComp = (OMX_COMPONENTTYPE*)hComponent;
(pComp->ComponentDeinit)(hComponent);
OMX_OSAL_Free(pComp);  /* OMX_OSAL_Free 为 OpenMAX IL 操作系统抽象层的内存释放函数 */
```


## 3.3.19 UseEGLImage
IL 客户端或隧道组件通过 **OMX_UseEGLImage** 核心宏调用组件的 `UseEGLImage` 方法（原文“OMX_UseBuffer”为错误，修正为“OMX_UseEGLImage”）。该方法的语义说明详见上文 3.2.2.19 节中 `OMX_UseEGLImage` 的定义。

UseEGLImage 的定义如下（原文“UseEGLImageBuffer”为命名错误，修正为“UseEGLImage”）：
```c
OMX_ERRORTYPE (*UseEGLImage)(
  OMX_IN OMX_HANDLETYPE hComponent,
  OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
  OMX_IN OMX_U32 nPortIndex,
  OMX_IN OMX_PTR pAppPrivate,
  OMX_IN void* pBuffer);  /* pBuffer 此处指向 EGLImage 对象 */
```


# 3.4 调用序列（Calling Sequences）
本节介绍 IL 客户端、OpenMAX IL 核心与组件在典型场景下的动态交互流程，包括初始化（initialization）、反初始化（de-initialization）、数据流（data flow）、数据隧道设置（data tunneling setup）、隧道数据流（data flow in tunneling）及端口动态重配置（dynamic port reconfiguration），同时还描述了核心、组件与资源管理器（resource manager）的交互方式。


## 3.4.1 初始化（Initialization）
本节介绍 OpenMAX IL 组件的初始化操作。组件可由 IL 客户端直接管理、组件间相互隧道连接，或两种方式兼具。为清晰区分，本节将“隧道模式”与“非隧道模式”分开说明，但实际组件框架中两种模式可共存。


### 3.4.1.1 非隧道模式初始化（Non-tunneled Initialization）
图 3-5 展示了 IL 客户端初始化 OpenMAX IL 组件的流程，具体步骤如下：

1. **创建组件与获取句柄**：
   - IL 客户端调用 `OMX_GetHandle` 函数，核心会触发实际的组件创建（步骤 1.1），并将组件的所有配置资源加载到内存；
   - 核心通过 `SetCallbacks` 方法将 IL 客户端的回调函数传递给组件（步骤 1.2）；
   - 若上述步骤成功，步骤 1.3 会返回有效的组件句柄，此时组件处于 **OMX_StateLoaded** 状态。

2. **配置组件与端口**：
   - IL 客户端需通过 **OMX_SetParameter** 核心宏配置组件及其端口，必要时可多次调用该宏（步骤 1.4）。

3. **设置缓冲区与状态转换**：
   - 配置完成后，IL 客户端请求组件从 **OMX_StateLoaded** 转换到 **OMX_StateIdle** 状态；
   - 仅在发送该状态转换请求后，IL 客户端才可为组件的所有端口设置缓冲区，需使用 `OMX_AllocateBuffer` 或 `OMX_UseBuffer`：
     - 若使用 `OMX_UseBuffer`，IL 客户端需自行分配缓冲区并传递给组件；
     - 若使用 `OMX_AllocateBuffer`，组件会分配缓冲区及对应的缓冲区头，并通过引用返回给 IL 客户端；
   - 缓冲区设置流程需根据端口数量及每个端口所需的缓冲区总数，重复执行多次；
   - 若 IL 客户端需为组件设置隧道，则无需自行分配缓冲区（由隧道组件负责分配），详见 3.4.1.2 节。

4. **完成初始化**：
   - 初始配置步骤完成后，组件会完成状态转换，并通过“`SendCommand` 请求完成事件”通知 IL 客户端（步骤 2.8）；
   - 此时组件已准备好供 IL 客户端使用。


### 3.4.1.2 隧道模式初始化（Tunneled Initialization）
为避免 IL 客户端与 OpenMAX IL 组件之间频繁来回传递数据缓冲区，可设置数据隧道，使一个组件的输出缓冲区直接传递给组件链中下一组件的输入端口。

以图 3-6 为例（IL 客户端为 A、B、C 三个隧道组件组成的链生成数据，其中 C 为接收器（sink），不向 IL 客户端返回数据），隧道设置与初始化流程如下：

#### 核心规则
- **回调管理**：无论端口使用专有通信还是隧道通信，所有回调均由 IL 客户端接收和管理；
- **组件创建**：通过 `OMX_GetHandle` 调用创建组件；
- **隧道链接**：将前一个组件的输出端口与后一个组件的输入端口链接，在此阶段确定“哪个端口是缓冲区提供者”；
- **提供者覆盖**：`OMX_SetupTunnel` 完成后，IL 客户端可通过“在输入端口设置缓冲区提供者”覆盖默认选择，输入端口会将新的提供者配置同步到输出端口；
- **状态转换限制**：从 **OMX_StateLoaded** 转换到 **OMX_StateIdle** 时，组件需等待所有已启用端口的必需缓冲区分配完成后，才可完成转换；
- **隧道设置时机**：仅当组件处于 **OMX_StateLoaded** 状态或端口已禁用时，才可执行 `OMX_SetupTunnel`。


#### 隧道设置流程（图 3-7）
1. **触发隧道设置**：当隧道组件处于 **OMX_StateLoaded** 状态时，IL 客户端调用核心的 `OMX_SetupTunnel` 函数，启动数据隧道设置（步骤 1.0）。
2. **调用 ComponentTunnelRequest**：
   - 核心会依次调用组件 A（输出端口所属组件）和组件 B（输入端口所属组件）的 `ComponentTunnelRequest` 方法；
   - 核心首先将 3.1.2.11 节定义的 `OMX_TUNNELSETUPTYPE` 结构传递给“输出端口所属组件”（组件 A），该组件填充结构后返回给核心（步骤 1.2）；
   - 若组件 A 的 `ComponentTunnelRequest` 调用成功，核心会将“组件 A 填充后的 `OMX_TUNNELSETUPTYPE` 结构”传递给组件 B，调用其 `ComponentTunnelRequest` 方法（步骤 1.3）；
   - 组件 B 需检查“对等组件（组件 A）的输出端口”与“自身输入端口”的兼容性（如数据类型需一致）（步骤 1.4）；
   - 若组件 B 同意结构中的隧道设置参数，会将协商结果回传给组件 A（步骤 1.5），并成功返回（步骤 1.6）。
3. **结果检查**：
   - 核心检查两个组件的 `ComponentTunnelRequest` 调用是否均无错误，若均成功，则初始的 `OMX_SetupTunnel` 调用返回成功；
   - 若组件 B 的 `ComponentTunnelRequest` 调用失败，核心会对组件 A 再次调用 `ComponentTunnelRequest`（将组件 B 的句柄和 `pTunnelSetup` 参数设为 NULL），使组件 A 切换为非隧道模式。


#### 缓冲区提供者覆盖流程（图 3-8）
若 IL 客户端需覆盖“隧道组件协商的缓冲区提供者”，需执行以下操作：
1. 在“提供输入端口的组件”上调用 `SetParameter` 函数，指定新的缓冲区提供者；
2. 该输入端口所属组件负责通过 `SetParameter` 调用，将新的提供者信息通知给另一个隧道组件。


#### 状态转换流程（图 3-9、3-10）
隧道初始化的最后一步是“从 **OMX_StateLoaded** 转换到 **OMX_StateIdle**”，此过程涉及缓冲区分配与分配，以“组件 A-组件 B（B 为提供者）、组件 B-组件 C（C 为提供者）”的链为例：
1. **缓冲区传递规则**：组件的每个提供者端口需通过 `OMX_UseBuffer`，将缓冲区传递给其隧道连接的非提供者端口；提供者端口传递完所有缓冲区后，组件需等待非提供者端口通过 `OMX_UseBuffer` 接收所有缓冲区，才可完成状态转换。
2. **具体交互**：
   - IL 客户端请求组件 A 转换状态，组件 A 需等待其输出端口接收所有必需缓冲区（由组件 B 提供）；
   - 同时，IL 客户端请求组件 B 转换状态，组件 B 的输入端口为提供者，需在组件 A 的输出端口上调用 `UseBuffer`，随后等待其输出端口接收所有必需缓冲区（由组件 C 提供）；
   - 组件 A 接收完所有缓冲区后，完成到 **OMX_StateIdle** 的转换；
   - IL 客户端请求组件 C 转换状态，组件 C 向组件 B 提供所需缓冲区后，因无需其他缓冲区，可直接完成状态转换；
   - 组件 B 接收完所有缓冲区后，最终完成到 **OMX_StateIdle** 的转换。
3. **灵活性说明**：状态转换的具体顺序可能因平台、操作系统和实现方式不同而变化，唯一规则是“等待所有资源可用”。


## 3.4.2 数据流（Data Flow）
OpenMAX IL 定义两种数据通信方式：
- **隧道通信（Tunneled Communication）**：端口直接与另一个组件的端口交换数据；
- **非隧道通信（Non-tunneled Communication）**：端口仅与 IL 客户端交换数据。

端口可借助平台特定特性（如 DMA、共享内存），通过专有通信实现数据隧道，以下分场景说明各通信方式的数据流。


### 3.4.2.1 非隧道模式数据流（Non-tunneled Data Flow）
核心交互规则如下：
1. **输入端口数据传递**：IL 客户端需调用 `OMX_EmptyThisBuffer`，将数据缓冲区传递给组件的输入端口；
2. **输出端口数据传递**：IL 客户端需先为组件的输出端口提供一个或多个空缓冲区（供组件写入输出数据），此操作通过 `OMX_FillThisBuffer` 完成；当组件输出端口有可用缓冲区时，会触发 `FillBufferDone` 回调（组件通过此前的 `SetCallbacks` 调用获取回调入口点）；
3. **数据移动责任**：若不使用数据隧道，IL 客户端需全权负责在组件间移动数据缓冲区。

具体动态交互流程详见图 3-11（非隧道组件间的数据流）。


### 3.4.2.2 隧道模式数据流（Tunneled Data Flow）
隧道模式下，OpenMAX IL 组件直接相互传递数据缓冲区，无需返回给 IL 客户端，具体规则因缓冲区提供者不同而异：
1. **输出组件为提供者**：输出组件需调用“另一个隧道组件”的 `OMX_EmptyThisBuffer`，传递待清空的缓冲区；输入组件完成操作后，需调用输出组件的 `OMX_FillThisBuffer`，将缓冲区返回给输出组件；
2. **输入组件为提供者**：通信机制与上述一致，但需从“调用输出组件的 `OMX_FillThisBuffer`”开始。

具体流程详见图 3-12（隧道组件间的数据流）。


### 3.4.2.3 专有通信（Proprietary Communication）
部分平台可通过专有通信机制（基于 DMA、共享内存等特定硬件）优化组件间的数据隧道，核心特点如下：
1. **配置时机**：专有通信的资源配置在“标准数据隧道设置阶段”以厂商自定义方式完成；IL 客户端仍使用标准 `OMX_SetupTunnel` 调用，平台会自动准备优化的组件间传输通道；
2. **数据流示例（图 3-13）**：
   - 假设组件 A、B、C 支持专有通信且均处于 **OMX_StateExecuting** 状态；
   - IL 客户端通过 `OMX_EmptyThisBuffer` 向组件 A 发送两个缓冲区（步骤 1.0、1.1）；
   - 组件 A 的输出通过隧道直接传递给组件 B 的输入，组件 B 的输出传递给作为接收器的组件 C；
   - 组件间通过专有机制移动数据，不触发回调；仅当组件 A 处理完缓冲区后，才会向 IL 客户端触发 `EmptyBufferDone` 回调；
   - 注意：即使不使用缓冲区相关回调，组件仍可通过 `EventHandler` 回调入口点向 IL 客户端生成事件。


## 3.4.3 反初始化（De-initialization）
本节分别介绍隧道模式与非隧道模式下组件的反初始化流程。


### 3.4.3.1 非隧道模式反初始化（Non-tunneled De-initialization）
IL 客户端停止组件执行并销毁组件的流程如下：
1. **状态转换到 Idle**：首先将组件切换到 **OMX_StateIdle** 状态，确保所有缓冲区归还给各自的提供者；
2. **状态转换到 Loaded**：Idle 状态转换完成后，请求组件转换到 **OMX_StateLoaded** 状态；
3. **释放缓冲区**：IL 客户端需为每个缓冲区调用 `OMX_FreeBuffer`，组件需从指定端口移除该缓冲区：
   - 若缓冲区由组件通过 `OMX_AllocateBuffer` 分配，组件还需释放缓冲区内存；
   - 若缓冲区由 IL 客户端分配并通过 `OMX_UseBuffer` 分配给组件，IL 客户端需在调用 `OMX_FreeBuffer` 后自行释放缓冲区内存；
4. **销毁组件**：所有缓冲区释放完成后，组件完成到 Loaded 状态的转换，IL 客户端调用 `OMX_FreeHandle` 函数销毁组件。

该流程需对每个非隧道端口执行，具体流程详见图 3-14（非隧道组件的反初始化）。


### 3.4.3.2 隧道模式反初始化（Tunneled De-initialization）
隧道端口所属组件的反初始化流程与非隧道模式类似，但需额外处理隧道间的缓冲区归还逻辑，具体流程详见图 3-15（隧道组件的反初始化）。


## 3.4.4 端口禁用与启用（Port Disablement and Enablement）
### 核心规则
- **端口禁用**：禁用端口的行为等同于“其所属组件转换到 **OMX_StateLoaded** 状态”，需执行：
  1. 将端口的所有缓冲区归还给提供者；
  2. 释放该端口分配的所有缓冲区；
- **端口启用**：启用端口的行为是禁用的逆过程，将“等效于 Loaded 状态的端口”切换到组件当前状态：
  1. 若组件处于“端口需分配缓冲区”的状态（如 Idle、Executing），则启用的端口会获取缓冲区；
  2. 若组件处于“缓冲区交换”状态（如 Executing），则启用的端口会开始交换缓冲区；
- **特殊场景**：若组件处于 **OMX_StateLoaded** 状态时禁用端口，该端口的有效状态仍与组件状态分离；因此，当组件从 Loaded 转换到 Idle 时，禁用的端口不会获取缓冲区，而是保持等效的 Loaded 状态。

以下分隧道模式与非隧道模式说明端口禁用与启用的具体流程。


### 3.4.4.1 隧道端口禁用与启用（Tunneled Ports Disablement and Enablement）
隧道端口的禁用与启用需同步处理隧道两端的端口，确保缓冲区正确归还与重新分配，具体行为详见图 3-16（隧道端口的禁用与启用）。


### 3.4.4.2 非隧道端口禁用与启用（Non-tunneled Port Disablement and Enablement）
非隧道端口的禁用与启用流程相对简单，主要涉及“缓冲区归还/释放”和“缓冲区重新分配”，具体流程详见图 3-17（非隧道端口的禁用与启用）。关于 `OMX_AllocateBuffer`、`OMX_UseBuffer` 和 `OMX_FreeBuffer` 的详细说明，分别参见 3.3.13、3.3.12 和 3.3.14 节。


## 3.4.5 端口动态重配置（Dynamic Port Reconfiguration）
本节介绍组件如何动态修改端口设置，典型应用场景包括：
- 视频解码器解析序列头后，发现输出图像的帧尺寸，需重新排列输出端口关联的缓冲区；
- 音频流参数动态变化，解码器需修改端口设置。

以图 3-18（视频解码器与视频渲染器通过 IL 客户端交换数据）为例，动态重配置流程如下：
1. **初始状态**：IL 客户端将视频解码器和渲染器设置为 **OMX_StateExecuting** 状态（步骤 1.0-1.3）；此时解码器输出端口和渲染器输入端口未配置（因输出帧尺寸未知，需解码器解析输入码流获取）；
2. **解析码流与触发事件**：IL 客户端向解码器发送第一个缓冲区（步骤 1.4），若该缓冲区包含视频序列头，解码器会解析并修改输出端口设置，随后通过 `OMX_EventPortSettingsChanged` 事件通知 IL 客户端（步骤 1.5）；
3. **禁用端口**：IL 客户端收到事件后，禁用解码器的输出端口和渲染器的输入端口（步骤 1.6-1.11）；
4. **重新配置**：
   - IL 客户端通过 `OMX_GetConfig` 读取新的端口设置；
   - 为解码器输出端口分配符合新尺寸的缓冲区；
   - 通过 `OMX_UseBuffer` 将新缓冲区告知渲染器（步骤 1.17）；
   - 通过 `OMX_SetConfig` 配置渲染器的输入端口（步骤 1.18）；
5. **恢复执行**：启用端口，恢复正常数据处理。


## 3.4.6 自动检测端口重配置（Autodetect Port Reconfiguration）
本节介绍组件如何修改“自动检测端口”的设置，典型应用场景包括：
- 文件读取器解析 3GPP 等媒体容器后，发现解码 elementary stream 所需的音视频解码器；
- 媒体容器的编码类型变化，文件读取器需在确定格式后修改端口设置。

以图 3-19（文件读取器、音频解码器、视频解码器的自动检测重配置）为例，流程如下：
1. **初始配置**：
   - IL 客户端将文件读取器的输出端口格式（`OMX_IndexParamVideoPortFormat`、`OMX_IndexParamAudioPortFormat`）设置为“自动检测（autodetect）”；
   - 仅实例化文件读取器，所有输出端口与 IL 客户端通信，且均设为自动检测模式；
   - 指令文件读取器转换到 **OMX_StateIdle**（分配缓冲区）和 **OMX_StateExecuting** 状态。
2. **格式检测与事件通知**：
   - 文件读取器读取并解析数据，直至确定媒体容器格式；
   - 若无法检测格式，生成 `OMX_ErrorFormatNotDetected` 错误通知 IL 客户端（步骤 1.6），IL 客户端可尝试使用其他文件读取器重复流程，直至检测成功或无可用读取器；
   - 若检测成功（包括容器格式和输出流格式），文件读取器修改输出端口设置，并通过 `OMX_EventPortFormatDetected` 和 `OMX_EventPortSettingsChanged` 事件通知 IL 客户端（步骤 1.8）；
3. **禁用端口与配置解码器**：
   - IL 客户端禁用文件读取器的已修改输出端口（步骤 1.9）；
   - 通过 `OMX_GetConfig` 读取新端口设置，根据设置选择合适的解码器，调用 `OMX_GetHandle` 创建解码器实例（步骤 1.11，解码器初始为 **OMX_StateLoaded** 状态）；
   - 通过 `OMX_SetParameter` 配置解码器及其端口（包括从读取器获取的格式设置），必要时可多次调用（步骤 1.12）；
4. **设置通信模式与恢复执行**：
   - IL 客户端可为组件设置非隧道通信（自行管理缓冲区）或隧道通信（组件管理缓冲区）；
   - 重新启用读取器的输出端口，将解码器转换到 **OMX_StateIdle** 和 **OMX_StateExecuting** 状态，恢复数据处理。


## 3.4.7 资源管理（Resource Management）
本节介绍资源管理的入口点，组件与资源管理器的接口仅作为示例，OpenMAX IL 标准仅定义 IL 客户端与组件的接口，IL 客户端可使用资源管理器入口点。


### 3.4.7.1 客户端无感知的资源管理（图 3-20）
此场景下 IL 客户端无需感知资源管理器的存在，核心特点如下：
- **组件实现**：OpenMAX IL 组件内部实现与资源管理器的异步调用，并向资源管理器提供“请求完成回调”；
- **透明性**：资源管理器仅在组件内部处理资源请求，IL 客户端无需执行特殊操作；
- **示例接口**：图中 `AcquireResourceRequest` 和 `AcquireResourceResponse` 为组件与资源管理器的交互示例接口，OpenMAX IL 标准不定义此类接口，组件与厂商特定管理器的交互细节也不在标准范围内。


### 3.4.7.2 资源竞争管理（图 3-21）
此场景为“两个优先级不同的组件（A、B）竞争同一资源”，流程如下：
1. **资源获取**：
   - IL 客户端通过“从 Loaded 到 Idle”的标准状态转换，为组件分配资源；
   - 组件 A 向资源管理器请求资源并获得所有权，转换到 Idle 状态，准备执行；
2. **资源竞争与错误处理**：
   - 组件 B 请求同一资源，资源管理器因“高优先级组件 A 已占用资源”而拒绝，通过 `OMX_ErrorInsufficientResources` 错误通知 IL 客户端 Y；
   - IL 客户端 Y 有两种选择：
     1. 指令组件 B 转换到 **OMX_StateWaitForResources** 状态，进入等待队列，直至资源可用；
     2. 指令组件 B 转换回 **OMX_StateLoaded** 状态；
3. **资源释放与恢复**：
   - 组件 A 转换到 Loaded 状态并释放资源，资源管理器检测到可用资源后，通知等待队列中的组件 B；
   - 组件 B 获取所有等待的资源后，通过 `OMX_EventResourcesAcquired` 事件通知 IL 客户端；
   - IL 客户端为组件 B 提供所有必需缓冲区，组件自动转换到 **OMX_StateIdle** 状态，并通知客户端状态变更（此为“自动状态转换”的特殊场景）；
4. **优先级与抢占**：IL 层不比较组件 A、B 的优先级，也不实现抢占机制，此职责由“与资源管理器通信的外部策略管理器”承担，策略管理器的描述不在 OpenMAX IL 标准范围内。


### 3.4.7.3 客户端主动使用资源管理 API（图 3-22、3-23）
1. **进入等待状态（图 3-22）**：
   - 若 IL 客户端希望“资源可用时收到通知”，可请求组件从 **OMX_StateLoaded** 转换到 **OMX_StateWaitForResources** 状态（详见 3.1.1.2.5 节）；
   - 组件进入资源管理器的等待队列，若资源已可用，则立即转换到 Idle 状态；
   - 无论何种情况，客户端都会收到两个对应“不同状态变更”的 `EventHandler` 回调；
   - 图中 `WaitForResourceRequest` 和 `WaitForResourceResponse` 为组件与资源管理器的交互示例接口，非标准定义。
2. **退出等待状态（图 3-23）**：
   - IL 客户端可在任意时间指令组件停止等待，此时需请求组件从 **OMX_StateWaitForResources** 转换回 **OMX_StateLoaded** 状态，将组件从等待队列中移除。
