# 2 OpenMAX IL简介与架构  
本文档本节将介绍OpenMAX IL的特性与架构。  


## 2.1 OpenMAX IL概述  
OpenMAX IL层是一套应用程序编程接口（API），它定义了一个软件接口，用于为系统中的软件组件提供访问层。该软件接口的设计目的是：针对初始化方式和命令处理逻辑各不相同的组件，提供一个具备**标准化命令集**和**标准化组件创建/销毁流程**的软件层。  


### 2.1.1 架构概述  
假设某系统需要实现4个多媒体处理功能，分别记为F1、F2、F3、F4。这些功能可能来自不同厂商，也可能由同一组织内的不同团队自研开发，且各自的初始化（setup）和销毁（teardown）需求、配置与数据传输方式都可能存在差异。  

OpenMAX IL API提供了一种机制，可将这些功能（单独或按逻辑组）封装为“组件（Component）”。该API包含一套标准协议，即使组件来自不同厂商/团队，只要符合该协议，就能实现组件间的数据交互，且可互相替换使用。  

OpenMAX IL API与上层实体（称为“IL客户端”，IL Client）交互。IL客户端通常是滤镜图多媒体框架（filter graph multimedia framework）、OpenMAX AL或应用程序中的功能模块。IL客户端通过一个中心化的IL实体——“核心（Core）”进行交互，具体包括：通过IL核心加载/卸载组件、建立两个OpenMAX IL组件间的直接通信、调用组件的方法。  

IL客户端始终通过IL核心与组件通信。多数情况下，这种通信等价于调用IL核心的某个宏（macro），该宏会直接映射为对某个组件方法的调用。以下场景为例外情况（需IL客户端调用实际的核心函数）：  
- 组件的创建与销毁；  
- 查询已安装的组件及其支持的角色（role）；  
- 通过隧道模式（tunneling）连接两个组件。  

组件是多媒体处理功能的载体。本规范明确定义了OpenMAX IL核心的功能，但组件的具体功能由组件提供者定义。组件处理的数据分为4类（根据组件导出的参数结构定义）：音频（audio）、视频（video）、图像（image）和其他类型（如用于同步的时间数据）。  

OpenMAX IL组件通过其“组件句柄（component handle）”提供一组标准的组件函数访问接口。这些函数支持IL客户端执行以下操作：  
- 获取/设置组件和端口的配置参数；  
- 获取/设置组件的状态；  
- 向组件发送命令；  
- 接收事件通知；  
- 分配缓冲区；  
- 建立与单个组件端口的通信；  
- 建立两个组件端口间的通信。  

所有符合OpenMAX IL规范的组件都必须至少包含一个端口（port）。尽管厂商可能提供无端口的OpenMAX IL兼容组件，但大部分合规性测试依赖于至少一个符合规范的端口。  

OpenMAX IL定义的4类端口对应其可传输的数据类型：音频端口、视频端口、图像端口和其他类型端口。每个端口根据其“消耗缓冲区（输入）”或“生成缓冲区（输出）”的特性，被定义为“输入端口”或“输出端口”。  

在包含F1、F2、F3、F4四个多媒体处理功能的系统中，系统实现者可为每个功能提供标准OpenMAX IL接口，也可灵活选择任意功能组合封装为组件——功能拆分的依据是“端口”。图2-1展示了实现这些功能的OpenMAX IL组件的几种可能划分方式。  

（原文图2-1：OpenMAX IL实现的几种可能划分方式）  
- 方式1：OpenMAXComponent A（包含F1、F2、F3、F4）；  
- 方式2：OpenMAXComponent B（包含F1、F2）、OpenMAXComponent C（包含F3、F4）；  
- 方式3：OpenMAXComponent A（包含F1）、OpenMAXComponent D（包含F2、F3、F4）；  

（原文页码：21）  


### 2.1.2 核心术语  
本节介绍描述OpenMAX IL API时常用的缩略词和定义。  

#### 2.1.2.1 核心定义  
表2-1列出了描述OpenMAX IL API时使用的核心定义。  

| 关键词（Key word） | 含义（Meaning） |
| --- | --- |
| 加速组件（Accelerated component） | 封装了“部分功能运行在加速器上”的OpenMAX IL组件。 |
| 加速器（Accelerator） | 用于加速特定功能处理的硬件，也可称为“加速硬件（accelerated hardware）”。注：加速器实际也可能是运行在其他处理器上的软件，而非硬件。 |
| 缓冲区提供者（Buffer Supplier） | “拥有”传入端口的缓冲区的实体。 |
| 容器（Container） | 用于封装 elementary 数据流及关联元数据的格式（如3gp文件格式）。 |
| 内容管道（Content Pipe） | 用于访问（读取或写入）OpenMAX IL外部内容的抽象机制。内容可能以文件形式存在，管道也可能借助系统文件I/O函数，但该抽象机制不限于这些特定内容类型或访问方式。 |
| 组件组（Component Group） | 功能上相互依赖的一组组件。若组内任一组件无法运行，则整个组的所有组件均无法运行。 |
| 组件挂起（Component Suspension） | 组件因缺少关键资源而挂起，但保留所有其他资源；当所需资源恢复可用时，组件可从挂起点恢复运行。 |
| 动态资源（Dynamic resources） | 组件首次转换到Idle（就绪）状态后才分配的资源。不建议使用动态资源分配，仅当“分配参数（如内部内存缓冲区的大小或数量）在首选资源分配时机无法确定”时，才考虑使用。 |
| 主机处理器（Host processor） | 多核系统中控制媒体加速的处理器，通常运行高层操作系统。 |
| IL客户端（IL client） | 调用核心或组件方法的软件层。IL客户端可能是GUI应用下层的图层（如GStreamer），也可能是GUI层下的多层结构。本文档中，“应用程序（application）”泛指所有调用OpenMAX IL方法的软件。 |
| 主内存（Main memory） | 通常指主机处理器与加速器共享的外部内存。 |
| OpenMAX IL组件（OpenMAX IL component） | 用于封装目标系统所需功能的组件。OpenMAX IL封装层为被封装的功能提供标准接口。 |
| OpenMAX IL核心（OpenMAX IL core） | 平台相关的代码，具备“定位OpenMAX IL组件并将其加载到主内存”的功能；当应用程序指示组件不再需要时，核心还负责将组件从内存中卸载。通常，OpenMAX IL核心将组件加载到内存后，不再参与应用程序与组件间的通信。 |
| 资源管理器（Resource manager） | 管理系统中硬件资源的软件实体。 |
| 静态资源（Static resources） | 组件进入Idle（就绪）状态前必须分配的资源。大多数组件资源属于此类。 |
| 同步（Synchronization） | 用于协调多个组件运行时序的机制。 |
| 隧道模式（Tunnels/Tunneling） | 建立并使用“两个OpenMAX IL组件间直接管理的标准数据路径”的过程。 |

（原文页码：22）  


### 2.1.3 系统组件  
图2-2展示了OpenMAX IL支持的各类通信方式。每个组件可拥有任意数量的用于数据通信的端口，具体分类如下：  
- 仅含一个输出端口的组件：源组件（source components）；  
- 仅含一个输入端口的组件：宿组件（sink components）；  
- 完全在主机处理器上运行的组件：主机组件（host components）；  
- 在松耦合加速器上运行的组件：加速组件（accelerator components）。  

OpenMAX IL可直接与应用程序集成，也可与多媒体框架组件集成，以支持异构实现。  

OpenMAX IL定义了3类通信方式：  
1. 非隧道模式通信（Non-tunneled communications）：IL客户端与组件间交换数据缓冲区的机制；  
2. 隧道模式通信（Tunneling）：组件间通过标准方式直接交换数据缓冲区的机制；  
3. 专有通信（Proprietary communication）：两个组件间直接数据通信的专有机制；若两个组件均支持，可在“隧道模式请求”时作为替代方案使用。  

（原文图2-2：OpenMAX IL API系统组件）  
- 上层：IL客户端（IL Client）、多媒体框架（Multimedia Framework）；  
- 中层：OpenMAX核心（OpenMAX Core）、多个组件（Component），包含源组件（Source Component）、主机组件（Host Component）、加速组件（Accelerator Component）、宿组件（Sink Component）；  
- 下层：硬件加速编解码器（Hardware Accelerated Codec）；  
- 通信方式：隧道模式通信（Tunneled Communication）、非隧道模式通信（Non-Tunneled Communication）、专有通信（Proprietary Communication）、进程间通信（IPC）。  

（原文页码：23）  


#### 2.1.3.1 组件配置文件（Component Profiles）  
OpenMAX IL组件功能分为两类配置文件（profile）：基础配置文件（base profile）和互操作配置文件（interop profile）。  

- **基础配置文件（base profile）**：  
  支持非隧道模式通信；可支持专有通信；不支持隧道模式通信。  

- **互操作配置文件（interop profile）**：  
  是基础配置文件的超集；必须支持非隧道模式通信和隧道模式通信；可支持专有通信。  

两类配置文件的核心区别在于“是否支持隧道模式通信”。基础配置文件通过简化实现降低了OpenMAX IL的落地门槛——无需实现隧道模式通信。  

表2-2：各组件配置文件支持的通信方式  

| 通信方式（Type of Communication） | 基础配置文件支持（Base Profile Support） | 互操作配置文件支持（Interop Profile Support） |
| --- | --- | --- |
| 非隧道模式通信（Non-Tunneled Communication） | 是（Yes） | 是（Yes） |
| 隧道模式通信（Tunneled Communication） | 否（No） | 是（Yes） |
| 专有通信（Proprietary Communication） | 是（Yes） | 是（Yes） |

（原文页码：24）  


### 2.1.4 组件状态  
每个OpenMAX IL组件都可经历一系列状态转换，如图2-3所示。组件的初始状态为“未加载（Unloaded）”，需通过调用OpenMAX IL核心将其加载；之后的所有状态转换均可通过与组件直接通信实现。  

（原文图2-3：组件状态）  
状态包含：UNLOADED（未加载）、LOADED（已加载）、IDLE（就绪）、EXECUTING（运行）、PAUSED（暂停）、INVALID（无效）、WAIT FOR RESOURCES（等待资源）。  

#### 状态转换规则与说明：  
1. **无效状态（INVALID）**：  
   当使用无效数据触发状态转换时，组件会进入无效状态。例如：若回调指针未指向有效地址，组件可能超时并向IL客户端上报错误。IL客户端检测到无效状态后，必须停止组件、反初始化、卸载并重新加载组件。  
   如图2-3所示，所有状态都可转换到无效状态，但退出无效状态的唯一方式是“卸载并重新加载组件”。  

2. **就绪状态（IDLE）**：  
   组件处于IDLE状态时，通常应拥有所有运行所需资源，但存在例外情况：若“资源分配参数在转换到IDLE状态时无法确定”，则资源分配可延迟。例如：视频解码组件需解析数据流后才能确定所需的参考帧数，但在转换到IDLE状态前无法解析数据流——此时组件可延迟分配资源；若动态分配失败，组件会进入挂起状态。  
   基于此，组件资源分为“静态资源（static resources）”和“动态资源（dynamic resources）”：前者是“转换到IDLE状态时提前分配的资源”，后者是“后续分配的资源”。  

   从LOADED（已加载）转换到IDLE（就绪）可能失败（因需分配所有运行所需的静态资源）。若转换失败，IL客户端可重试，或选择将组件转入WAIT FOR RESOURCES（等待资源）状态。组件进入等待资源状态后，会向厂商特定的资源管理器注册，以在资源可用时收到通知，随后组件将自动转换到IDLE状态。  
   除“转换到INVALID状态”外，其他所有状态转换均由IL客户端发送的命令控制。  

3. **各状态核心含义**：  
   - IDLE（就绪）：组件拥有所有所需静态资源，但不处理数据；  
   - EXECUTING（运行）：组件等待接收待处理的缓冲区，且会按第3章规定触发所需回调；  
   - PAUSED（暂停）：组件保留缓冲区运行上下文，但不处理数据或交换缓冲区；  
   - 状态转换影响：  
     - 从PAUSED转换到EXECUTING：组件从暂停点恢复缓冲区处理；  
     - 从EXECUTING/PAUSED转换到IDLE：缓冲区处理上下文丢失，需重新引入流的起始部分；  
     - 从IDLE转换到LOADED：通信缓冲区等运行资源丢失。  

（原文页码：25）  


### 2.1.5 组件架构  
图2-4展示了组件的架构。需注意：组件仅有一个入口点（通过其句柄访问标准函数数组），但出口调用的数量取决于组件的端口数量——具体特性如下：  
1. 每个组件会调用指定的IL客户端事件处理器（IL client event handler）；  
2. 每个端口也会调用（或回调）指定的外部函数；  
3. 每个端口关联一个“缓冲区头指针队列（queue for pointers to buffer headers）”，这些缓冲区头指向实际的缓冲区；  
4. 命令函数（command function）也有一个命令队列；  
5. 所有参数或配置调用均针对特定索引（index）执行，并包含与该参数/配置关联的结构（如图2-4所示）。  

（原文图2-4：OpenMAX IL API组件架构）  
- 左侧：IL客户端（IL Client）或其他组件；  
- 中间：组件句柄（Component Handle）、命令队列（Command Queue）、IL客户端事件处理器（IL Client Event Handler）、组件事件处理器（Component Event Handler）；  
- 右侧：端口A（Port A，含输入/输出缓冲区头指针队列、回调函数）、端口B（Port B，含输入/输出缓冲区头指针队列、回调函数）；  
- 交互：配置参数/SET/GET（Configuration Parameter/SET/GET）、缓冲区发送（Buffer Sent）。  

端口需支持对IL客户端的回调；若端口属于互操作配置文件（interop profile）的组件，还需支持与其他组件端口的通信。  

（原文页码：26）  


### 2.1.6 通信行为  
#### 配置与调用时机：  
当从OpenMAX IL核心获取组件句柄后，即可配置组件。组件的数据通信调用为“非阻塞（non-blocking）”，需满足以下条件才会启用：  
1. 端口数量已配置；  
2. 每个端口已配置为特定数据格式；  
3. 组件已转入合适状态。  

#### 端口通信规则：  
数据通信与组件的特定端口绑定，具体调用方式如下：  
- 输入端口：IL客户端通过`OMX_EmptyThisBuffer`函数调用（详见3.2.2.17节）；  
- 输出端口：IL客户端通过`OMX_FillThisBuffer`函数调用（详见3.2.2.18节）。  

#### 上下文实现差异：  
- 内上下文（in-context）实现：`EmptyBufferDone`或`FillBufferDone`回调会在函数返回前触发；  
- 外上下文（out-of-context）实现：回调触发时机与函数返回无关。  

图2-5展示了内上下文与外上下文实现的预期行为。需注意：IL客户端不应假设返回/回调的顺序，以支持内上下文和外上下文OpenMAX IL组件的异构集成。  

（原文图2-5：外上下文与内上下文操作对比）  
- 外上下文（Out-of-Context）：调用（Calling）→ 应用程序/框架（Application/Framework）→ OpenMAX组件（OpenMAX Component，运行在与应用程序/框架不同的线程/进程）→ 参数检查（Parametric Check）→ 返回（Return）→ 回调（Callback）；  
- 内上下文（In-Context）：调用（Calling）→ 应用程序/框架（Application/Framework）→ OpenMAX组件（OpenMAX Component，运行在与应用程序/框架相同的线程/进程）→ 参数检查（Parametric Check）→ 回调（Callback）→ 返回（Return）。  

#### 缓冲区管理：  
每个端口有组件定义的“最小缓冲区数量”（需分配或使用），且每个缓冲区会关联一个“缓冲区头（buffer header）”——缓冲区头引用缓冲区中的数据，并提供与数据内容关联的元数据。  

所有组件端口需支持“自行分配缓冲区”或“使用预分配缓冲区”，两种方式中通常有一种更高效。  

（原文页码：27）  


### 2.1.7 隧道模式缓冲区分配  
本节介绍隧道模式组件的缓冲区分配规则。对于某一隧道，**仅一个端口提供缓冲区**，并将其传递给“非提供方端口”。通常，隧道的提供方端口（supplier port）也负责分配缓冲区；但在特定情况下，隧道模式组件可选择“在一个端口复用另一个端口的缓冲区”，以避免内存拷贝、优化内存使用——这种可选机制称为“缓冲区共享（buffer sharing）”，详见第10章“实现缓冲区共享（Implementing Buffer Sharing）”。  

图2-6展示了隧道模式缓冲区分配的相关概念。  

（原文图2-6：缓冲区分配与共享关系示例）  
- 组件1（Component 1）、组件2（Component 2）、组件3（Component 3）；  
- 端口交互：端口a（Port a）分配缓冲区K（Buffer K）→ 端口b（Port b）调用`UseBuffer(K)` → 端口c（Port c）共享缓冲区K（share K）→ 端口d（Port d）调用`UseBuffer(K)`。  

#### 核心端口定义：  
1. 提供者端口（supplier port）：在隧道模式的端口对中，向相邻端口调用`UseBuffer`函数的端口。提供者端口不一定自行分配缓冲区，也可复用同一组件上其他端口的缓冲区（如图2-6中的端口a和端口c）。  
2. 非提供者端口（non-supplier port）：接收相邻端口`UseBuffer`调用的端口（如图2-6中的端口b和端口d）。  
3. 隧道端口（tunneling port）：与某端口共享隧道的相邻端口（例如：图2-6中端口b是端口a的隧道端口，反之亦然）。  
4. 分配器端口（allocator port）：自行分配缓冲区的提供者端口（如图2-6中仅端口a是分配器端口）。  
5. 共享端口（sharing port）：复用同一组件上其他端口缓冲区的端口（如图2-6中的端口c）。  
6. 隧道模式组件（tunneling component）：至少使用一个隧道的组件。  

#### 缓冲区需求规则：  
端口的“缓冲区需求集”包含“所需缓冲区数量”和“每个缓冲区的所需大小”。多个缓冲区需求集的“最大值”定义为：所有集合中“最大缓冲区数量”与“最大缓冲区大小”的组合。  

某端口可通过以下方式获取隧道端口的缓冲区需求：对隧道端口所属的组件调用`OMX_GetParameter`函数，通过`OMX_PARAM_PORTDEFINITIONTYPE`结构体获取。注：若某端口与另一端口共享缓冲区（同属一个组件），则无需调用`OMX_GetParameter`即可确定缓冲区需求。  

#### 组件外部语义规则：  
无论组件是否共享缓冲区，都必须遵守以下外部语义：  
1. 在所有提供者端口上提供缓冲区；  
2. 准确传达各端口的缓冲区需求；  
3. 通过`OMX_EmptyThisBuffer`调用将缓冲区从输出端口传递到输入端口；  
4. 通过`OMX_FillThisBuffer`调用将缓冲区从输入端口返回给输出端口。  


#### 2.1.7.1 IL客户端组件设置  
要设置隧道模式组件，IL客户端需按以下顺序执行设置操作：  
1. 加载所有隧道模式组件，并在这些组件上建立隧道；  
2. 发送命令，使所有隧道模式组件从LOADED（已加载）状态转换到IDLE（就绪）状态。  

注：若部分组件共享缓冲区时，IL客户端未按此方式操作，可能因组件间的依赖关系导致隧道模式组件无法转换到IDLE状态。  

（原文页码：29）  


#### 2.1.7.2 组件从LOADED到IDLE状态的转换  
当组件收到“从LOADED转换到IDLE”的命令时，非共享组件（non-sharing component）的每个提供者端口会执行以下操作：  
1. 通过`OMX_GetParameter`调用获取其隧道端口的缓冲区需求；  
2. 按“自身需求与隧道端口需求的最大值”分配缓冲区；  
3. 在其隧道端口上调用`OMX_UseBuffer`函数。  


### 2.1.8 端口重新连接  
端口重新连接功能支持“用一个隧道模式组件替换另一个”，且无需销毁周边组件。以图2-7为例，若需用组件B2替换组件B1，需执行以下步骤：  
1. 发送“端口禁用命令”，禁用组件A的输出端口和组件B1的输入端口；  
2. 等待所有已分配的缓冲区返回给其合法所有者并释放后，将组件A的输出端口连接到组件B2的输入端口；  
3. 同理，发送“端口禁用命令”，禁用组件B1的输出端口和组件C的输入端口；  
4. 等待所有已分配的缓冲区返回并释放后，将组件C的输入端口连接到组件B2的输出端口；  
5. 发送“端口启用命令”，启用所有端口。  

更多关于端口禁用与启用的信息，详见3.4.4节“端口禁用与启用（Port Disablement and Enablement）”。  

（原文图2-7：端口重新连接）  
步骤1：组件A→组件B1→组件C（原连接）；  
步骤2：组件A→组件B2（断开A与B1，连接A与B2）；  
步骤3：组件B1→组件C（断开B1与C）；  
步骤4：组件A→组件B2→组件C（完成B2替换B1）。  

#### 音频场景的特殊需求：  
在音频等场景中，可能需要“将一个组件重新连接到另一个组件”，并实现“新组件数据淡入、原组件数据淡出”。图2-8展示了该场景的实现流程：  
1. 初始状态：组件A向组件B1发送数据，组件B1向组件C发送数据；组件A和C各有一个禁用的额外端口；  
2. IL客户端操作：建立组件A与B2的隧道、建立组件B2与C的隧道，然后启用这两个隧道的所有端口；若为音频组件，组件C可按不同增益混合B1和B2的数据；  
3. 禁用组件A与B1、组件C与B1连接的端口，然后释放组件B1的资源。  

（原文图2-8：组件重新连接（音频场景））  
步骤1：A→B1→C；  
步骤2：A→B1→C、A→B2→C（双连接，混合数据）；  
步骤3：A→B2→C（断开B1连接）。  

（原文页码：31）  


### 2.1.9 队列与刷新（Flush）  
组件的“命令队列（command queue）”支持以下功能：  
- 在非隧道模式通信中：刷新未处理的缓冲区，并将其返回给IL客户端；  
- 在隧道模式通信中：刷新未处理的缓冲区，并将其返回给隧道输出端口。  

**示例**：假设某组件的输出端口使用IL客户端分配的缓冲区。IL客户端在发送“刷新命令”前，先向组件发送了5个缓冲区。组件处理刷新命令时，会执行以下操作：  
1. 返回所有未处理的缓冲区；  
2. 触发事件处理器，通知IL客户端。  

若刷新命令处理前已有2个缓冲区处理完成，则组件会返回剩余3个未填充的缓冲区，并生成事件。IL客户端需等待该事件触发后，再尝试反初始化组件。  


### 2.1.10 缓冲区标记（Marking Buffers）  
IL客户端可设置“标记缓冲区（marked buffer）”——当组件遇到该缓冲区时，会触发事件。缓冲区可通过其“缓冲区头”进行标记，且该标记会在OpenMAX IL组件链中从输入缓冲区“内部传递”到输出缓冲区。  

图2-9展示了缓冲区标记的工作流程：IL客户端发送“标记缓冲区”命令→组件A的输出端口发送标记为B1的缓冲区→组件B处理B1缓冲区，生成标记为B2的输出缓冲区→组件C的输入端口接收B2缓冲区，处理完成后触发事件处理器。  

（原文图2-9：缓冲区标记）  
- 左侧：IL客户端（IL Client）发送“标记缓冲区（Mark Buffer）”命令；  
- 中间：组件A（A）→组件B（B）→组件C（C），缓冲区从B1传递到B2；  
- 右侧：组件C向IL客户端发送“标记缓冲区事件（Marked Buffer Event）”。  

（原文页码：32）  


### 2.1.11 事件与回调（Events and Callbacks）  
组件向IL客户端发送的事件分为6类：  
1. 错误事件（Error events）：已枚举定义，可在任意时间触发；  
2. 命令完成通知事件（Command complete notification events）：命令成功执行后触发；  
3. 标记缓冲区事件（Marked buffer events）：组件检测到标记缓冲区时触发；  
4. 端口设置变更通知事件（Port settings changed notification events）：组件修改端口设置时生成；  
5. 缓冲区标志事件（Buffer flag events）：检测到流结束（end of stream）时触发；  
6. 资源获取事件（Resources acquired events）：组件获取等待的资源时生成。  

端口的“缓冲区处理回调”在以下场景触发：  
- 缓冲区可用时；  
- 需指示“需要缓冲区”时。  

（原文页码：33）  


### 2.1.12 缓冲区有效数据（Buffer Payload）  
端口配置用于“确定和定义组件端口上传输数据的格式”，但不定义“数据在缓冲区中的存储方式”。  

#### 缓冲区有效数据的通用定义：  
无论数据如何存储，缓冲区中“有效数据的范围和位置”均由缓冲区头的以下3个参数定义：  
- `pBuffer`：指向缓冲区起始地址的指针；  
- `nOffset`：缓冲区起始地址到有效数据起始地址的字节数；  
- `nFilledLen`：缓冲区中有效数据的连续字节数。  

因此，有效数据的地址范围为：`pBuffer + nOffset` 到 `pBuffer + nOffset + nFilledLen`。  


#### 压缩数据的3种存储场景：  
以下3种场景描述了“解码或编码时，压缩数据在缓冲区中的存储方式”，每种场景各有优势（注：缓冲区仅作为数据传输载体，内容要求由端口配置参数定义）。  

（场景中阴影部分表示数据，空白部分表示无数据）  

##### 场景1：缓冲区部分或完全填充数据  
适用于包含压缩数据帧的缓冲区（帧标记为f1到fn）。  

（原文图2-10：场景1——缓冲区部分或完全填充数据）  
- 缓冲区1（buffer 1）：f1；  
- 缓冲区2（buffer 2）：f2；  
- 缓冲区3（buffer 3）：f3；  
- 缓冲区4（buffer 4）：f4；  
- 缓冲区n（buffer n）：fn；  
（注：每个缓冲区可包含一个或多个帧）  

**优势**：解码播放场景中，单个缓冲区可容纳多个帧，减少“为解码缓冲数据”所需的事务数。  
**不足**：解码器需解析数据以提取帧；可能需要“帧构建缓冲区（frame-building buffer）”存储解析后的数据，或维护“待后续缓冲区补充完整的部分帧”。  

（原文页码：34）  


##### 场景2：缓冲区仅填充完整压缩帧  
（原文图2-11：场景2——缓冲区仅填充完整压缩帧）  
- 缓冲区1（buffer 1）：f1；  
- 缓冲区2（buffer 2）：f2；  
- 缓冲区3（buffer 3）：f3；  
- 缓冲区4（buffer 4）：f4；  
- 缓冲区n（buffer n）：fn；  
（注：每个缓冲区仅包含完整帧，无部分帧）  

**与场景1的区别**：需先解析压缩数据，确保仅将完整帧放入缓冲区。  
**优势**：解码器可能无需“场景1中用于解析帧的额外工作缓冲区”。  
**不足**：仍需解码器解析数据以完成解码。  


##### 场景3：缓冲区仅填充一个压缩帧  
（原文图2-12：场景3——缓冲区仅填充一个压缩帧）  
- 缓冲区1（buffer 1）：f1；  
- 缓冲区2（buffer 2）：f2；  
- 缓冲区3（buffer 3）：f3；  
- 缓冲区4（buffer 4）：f4；  
- 缓冲区n（buffer n）：fn；  
（注：每个缓冲区仅包含一个完整帧）  

**优势**：解码器无需解析数据（解析工作由源组件完成）。  
**不足**：数据传输存在瓶颈——每次传输仅能传递一个帧；根据实现方式，“每帧一次事务”对性能的影响可能大于“从缓冲区解析帧”。  


#### 场景兼容性规则：  
1. 解码器或编码器组件至少需支持场景1；  
2. 若编解码器组件支持场景1，且压缩格式允许“字节对齐的帧边界”，则该组件也可支持场景2和场景3；  
3. 特殊情况：例如，将自适应多速率（AMR）编解码器配置为“RTP载荷格式-带宽高效模式”时，该格式定义的“非字节对齐帧”无法满足场景2或3的“字节对齐帧边界”要求，此时使用场景2或3无意义。  


#### 注意事项：  
当“为解码器输入”或“为编码器输出”填充压缩数据时，若限制“仅填充完整帧”，可能因“帧非字节对齐”导致问题：需在“格式规范定义的填充”之外额外添加填充数据，且后续需移除该填充数据（因无法直接追加）——这需要“了解标准规范之外的填充位信息”，且不同组件的处理方式可能不同。  

为保证互操作性，**不应假设或要求缓冲区中的内容包含特定数量的完整帧**：  
- 对于未压缩数据格式：每个缓冲区至少包含一个完整的数据单元；  
- 对于压缩数据格式：无“每个缓冲区内容量”的限制。  

（原文页码：35）  


### 2.1.13 缓冲区标志与时间戳（Buffer Flags and Timestamps）  
#### 缓冲区标志（Buffer Flags）：  
用于将特定属性（如“流结束（end of stream）”）与缓冲区中的数据关联。  

#### 缓冲区时间戳（Buffer Timestamps）：  
用于将“演示时间（以微秒为单位）”与缓冲区数据关联，以控制数据的渲染时序。一旦时间戳与缓冲区关联，**任何组件都不应为“速率控制或同步”修改该时间戳**（速率控制和同步由时钟组件实现）。  

#### 元数据传递规则：  
缓冲区元数据（即标志和时间戳）仅适用于“缓冲区中的第一个新逻辑单元”。若缓冲区包含多个逻辑单元：  
- 元数据仅对“起始边界最先出现的逻辑单元”生效；  
- 后续逻辑单元无显式标志或时间戳；  
- 若需为每个逻辑单元添加显式标志和时间戳，则每个缓冲区应包含不超过一个逻辑单元。  

除非另有说明（如标志定义中），否则组件收到“带标志或时间戳的输入逻辑单元”后，需将该元数据复制到“该输入单元所生成的所有输出逻辑单元”中。  


### 2.1.14 同步（Synchronization）  
同步功能通过“时钟组件（clock component）”的“同步端口（sync port）”实现。同步端口和时钟组件属于“其他（other）”域，其运行遵循与数据端口相同的协议和调用规则。  

#### 时钟组件核心功能：  
1. 维护“媒体时钟（media clock）”：基于音频和视频参考时钟，跟踪媒体流中的位置；  
2. 传输时间信息：通过同步端口向客户端组件发送“包含时间信息的缓冲区”——缓冲区中包含“媒体时间更新（media time update）”，涵盖媒体时钟的当前位置、缩放比例（scale）和状态。  

#### 客户端组件同步逻辑：  
客户端组件可通过以下方式将“操作时序（如视频帧渲染）”与时间戳对齐：  
1. 向时钟组件发送请求：当媒体时钟与目标时间戳匹配时，发送该时间戳；  
2. 客户端组件收到“请求的时间戳”（通过同步端口）后，执行相应操作。  

图2-13展示了“组件配置示例中的时间与数据缓冲区流向”：  
- 数据流向：文件读取器/解复用器（File Reader/Demux）→ 音频解码器（Audio Decoder）→ 音频渲染器（Audio Renderer）；文件读取器/解复用器→ 视频解码器（Video Decoder）→ 视频调度器（Video Scheduler）→ 视频渲染器（Video Renderer）；  
- 时间流向：时钟组件（Clock Component）→ 音频渲染器、视频调度器（提供同步时间）。  

（原文图2-13：时间与数据缓冲区流向）  

（原文页码：36）  


### 2.1.15 速率控制（Rate Control）  
时钟组件还通过“暴露媒体时钟配置接口”实现所有速率控制功能。IL客户端可通过“修改媒体时钟的缩放比例（scale factor）”实现以下功能：  
- 控制媒体时钟的推进速率和方向；  
- 实现播放（play）、快进（fast forward）、倒放（rewind）、暂停（pause）、慢动作（slow motion）等特技模式（trick modes）。  

IL客户端还可通过这些配置“启动或停止时钟”（修改媒体时钟的状态）。当媒体时钟的缩放比例或状态变化时，时钟组件会通过“所有同步端口发送包含新缩放比例或状态的媒体时间更新”，确保所有客户端组件感知该变化。  

组件不应因“缩放比例变化”修改缓冲区时间戳，但可据此调整处理逻辑。例如：音频组件在特技模式下可“缩放音频并校正音调”，或完全停止发送输出。  


### 2.1.16 组件注册（Component Registration）  
组件向核心注册的方式通常是“核心相关的（core specific）”，但存在以下标准场景：  

若核心支持“组件静态链接（static linking）”，则需支持第3章所述的“标准编译时组件注册方案”。厂商可通过以下方式提供“适用于所有支持静态链接的核心”的组件：  
- 将组件信息放入“与组件和核心都链接的数据结构”中。  

组件可通过该机制静态注册，但其主体代码仍可动态加载。  

组件需提供“获取其支持的标准组件角色（standard component roles）”的接口，核心可借助该接口向IL客户端暴露与角色相关的信息。  


### 2.1.17 资源管理（Resource Management）  
本节讨论OpenMAX IL API中资源管理的作用。  

（原文页码：37）  


#### 2.1.17.1 资源管理的必要性  
当组件因“缺少资源”无法进入IDLE状态时，IL客户端存在以下问题：  
- 不知道哪些资源受限；  
- 不知道哪些组件在使用该资源；  
- 无法解决资源冲突。  

因此，OpenMAX IL需引入资源管理机制。  

OpenMAX IL的目标之一是“通过IL层为上层提供硬件无关性”，要实现该目标，需明确资源管理的以下要求：  
1. IL客户端（如软件平台中的多媒体插件）无需了解：  
   - IL实现的细节；  
   - IL组件使用的具体资源；  
2. 发生资源冲突时，IL客户端可依赖“跨IL实现和硬件平台的一致组件行为”。  

IL客户端不应直接与“厂商特定的硬件资源管理器”交互，原因如下：  
- 违背“硬件无关性”目标；  
- 增加IL客户端的返工成本，影响其在多硬件平台上的可复用性。  

尽管OpenMAX IL API 1.1版本未完全解决资源管理问题，但已通过以下方式预留了“资源管理钩子（hooks）”：  
- 行为规则（behavioral rules）；  
- 组件优先级（component priorities）；  
- 与资源管理相关的组件状态。  

这些钩子为后续OpenMAX IL API版本的“完整资源管理”奠定了基础。  


#### 术语定义：  
- **资源管理（Resource management）**：负责管理组件对“受限资源”的访问。资源管理器需掌握以下信息：  
  1. 特定资源的可用量；  
  2. 当前使用该资源的组件；  
  3. 各组件的资源使用量。  
  资源管理器会根据“资源冲突和可用性”，向“策略（Policy）”建议“应抢占（preempt）或恢复哪些组件”。  

- **策略（Policy）**：负责管理组件链或流。策略需根据“资源、系统配置及其他因素”判断“流是否可运行”。  


#### 2.1.17.2 示例架构  
图2-14展示了“基于OpenMAX IL的系统高层架构示例”。该示例中：  
- 应用程序（Applications）与IL层之间存在“含策略管理器（Policy Mgr）的多媒体框架（Multimedia Framework）”；  
- 系统包含多个硬件平台（供不同OpenMAX IL组件使用），且由“多个厂商特定的硬件资源管理器”管理；  
- 该架构也支持“单个中心化资源管理器”。  

该示例架构为“组件优先级、行为规则和硬件特定资源管理器”的讨论提供背景，但相关讨论适用于所有基于OpenMAX IL的架构。  

（原文图2-14：示例架构）  
- 上层：应用程序（Applications）；  
- 中层：多媒体框架（Multimedia Framework，含策略管理器）、OpenMAX IL（含核心和组件接口）、组件（Component A1/A2/An、Component B1/B2/Bn）；  
- 下层：硬件A适配层（含A硬件特定资源管理器）、硬件B适配层（含B硬件特定资源管理器）；  
- 注：资源管理器始终是硬件厂商特定的。  

（原文页码：38）  


#### 2.1.17.3 组件优先级（Component Priorities）  
每个IL组件都有一个“优先级值（OMX_U32类型整数）”，由IL客户端设置，规则如下：  
1. 优先级按“降序”排列：0表示最高优先级；  
2. 优先级相同的组件：“最近获取资源的组件”优先级高于“较早获取资源的组件”（冲突解决规则）。  

IL客户端还可为IL组件分配“组优先级（group priority）”：同一组ID（group ID）的所有组件保持相同的组优先级。  


#### 2.1.17.4 行为规则（Behavioral Rules）  
IL层定义以下行为规则：  

1. **OMX_ErrorInsufficientResources错误触发条件**：  
   仅当“组件尝试进入IDLE状态时，资源不足且无法通过抢占低优先级组件释放足够资源”时，才会调用该错误。  

2. **组件抢占感知**：  
   当组件尝试进入IDLE状态，且其所需资源需通过“抢占低优先级组件”释放时，该组件不会感知到“抢占正在发生”。  

3. **资源抢占相关错误**：  
   - 若组件的资源需被抢占，当它从EXECUTING（运行）或PAUSED（暂停）状态转换到IDLE状态时，会向IL客户端发送`OMX_ErrorResourcesPreempted`错误；  
   - 当资源释放后，组件从IDLE状态转换到LOADED（已加载）状态时，会向IL客户端发送`OMX_ErrorResourcesLost`错误。  

4. **资源可用通知**：  
   若IL客户端需“知道组件关联的流何时可恢复或启动”，需请求“资源可用时通知”——通过将组件转入`OMX_StateWaitForResources`（等待资源）状态实现。当资源可用时，组件会自动转换到IDLE状态；IL客户端收到“组件进入IDLE状态”的通知后，可尝试将“组件链中的其他组件”也转入IDLE状态。  

   该“自动转换到IDLE状态”的机制可确保：当多个IL客户端等待同一资源时，资源一可用，IL客户端就能立即恢复或启动流。若组件仅自动转换到LOADED状态，则其他IL客户端可能抢先获取该资源。  

以上行为规则仅覆盖IL客户端与IL组件间的交互。  

（原文页码：39）  


#### 2.1.17.5 厂商特定的硬件资源管理器  
为实现上述行为规则，厂商特定的硬件资源管理器可存在，并执行以下功能：  
1. 实现并管理等待队列（wait queue）；  
2. 跟踪资源可用量；  
3. 跟踪“拥有资源的组件”及“各组件使用的资源类型”；  
4. 当高优先级组件请求资源时，通知“需释放资源的一个或多个组件”；  
5. 当资源可用时，通知“等待该资源的最高优先级组件”。  

组件与“厂商特定的硬件资源管理器”间的实际交互是“厂商特定的”，超出本文档范围。第3章提供了更多与“优先级和资源管理”相关的参数结构和用例细节。  


#### 2.1.17.6 组件挂起（Component Suspension）  
当组件缺少“处理数据所需的足够资源”时，可选择“挂起自身”，以实现更优的动态资源管理。组件挂起适用于以下两类场景：  
1. 组件丢失关键资源，且该丢失是暂时的；  
2. 关键资源的动态分配失败。  

若组件无法挂起，则面对“资源被抢占或丢失”时，唯一的应对方式是“通过转换到IDLE→LOADED状态进行反初始化”——这会导致“数据流状态丢失”（因缓冲区需返回给分配者）。而挂起机制允许组件“保留状态”，以便在延迟后从挂起点恢复运行。  


#### 组件挂起的核心规则：  
1. **挂起的状态范围**：  
   挂起是组件在“IDLE（就绪）”或“PAUSED（暂停）”状态下的属性。仅当组件“丢失一个或多个关键资源（导致无法处理数据）”时，才被视为“挂起”。  
   组件无法在“EXECUTING（运行）”状态下挂起（因“运行”意味着“数据可用时即可处理或输出数据”）。因此，组件仅可在“IDLE或PAUSED状态”（正常持有部分资源但不处理数据）下挂起。  

2. **状态转换规则**：  
   组件挂起无需新增组件状态，但需新增“组件主动触发的状态转换”：运行中的组件（EXECUTING状态）挂起时，会自行从EXECUTING转换到PAUSED状态。  

   IL客户端可对挂起的组件执行“常规状态转换”，但存在以下例外：  
   - 无法将挂起的组件转换到EXECUTING状态；  
   - 若尝试该转换，会失败并返回`OMX_ErrorComponentSuspended`错误。  


### 2.1.18 内容管道（Content Pipes）  
IL组件可借助“内容管道”实现以下功能：  
- 同步地从“源（如文件流）”拉取内容，或向“目标”推送内容；  
- 抽象“源/目标的平台实现细节”（如本地文件、远程文件、广播等）。  

#### 内容管道的定义：  
内容管道是一个“对象”，通过实现“内容管道结构中定义的数据访问抽象接口”，提供内容访问能力。  

#### 内容管道接口功能：  
1. **常规内容操作**：  
   - 打开、关闭、创建内容；  
   - 定位到内容中的特定位置；  
   - 获取当前在内容中的位置；  
   - 从当前位置读取数据；  
   - 向当前位置写入数据。  

2. **异步流场景支持**：  
   对于“需与远程位置异步传输数据”的内容管道实现（如远程文件读取/写入），管道可能存在“无法立即提供数据（读取场景）”或“无法立即接收数据（写入场景）”的情况，且这类管道可能维护自身的数据缓存。针对此类场景，接口支持以下功能：  
   - 检查管道的可用字节数（输入或输出），以确认管道客户端是否可执行后续读取/写入操作；  
   - 通过“管道提供的缓冲区”读取或写入数据，避免“管道缓冲区与客户端缓冲区间的不必要内存拷贝”。  

#### 内容管道的获取方式：  
1. 组件（如容器解复用器或复用器）通过调用IL核心的`OMX_GetContentPipe`函数，从IL核心获取内容管道；  
2. IL客户端可通过`OMX_IndexParamCustomContentPipe`配置，提供“自定义内容管道”（如客户端自行实现内容管道时）；  
3. IL客户端通过`OMX_IndexParamContentURI`参数，将“目标内容”指定为URI格式。  

（原文页码：41）  


### 2.1.19 文件解析（File Parsing）  
OpenMAX IL 1.1版本定义了以下内容：  
1. 标准容器格式解复用器（standard container format demuxers）；  
2. 支持“组件文件解析功能”的机制。  

这些机制包括：  
1. 组件可指示“是否成功检测并支持所接收的数据流格式”；  
2. 组件可检查并选择“其输出端口上可用的流”（当存在多个备选流时）；  
3. IL客户端可“遍历、提取和过滤”组件从数据流中捕获的元数据。  


### 2.1.20 视频解码器错误映射（Video Decoder Error Mapping）  
视频解码器组件可“向IL客户端报告解码流时遇到的宏块（MB）错误”。IL客户端可通过“专用参数”，随时查询组件“已遇到的宏块错误映射（MB error map）”。  

#### 典型应用场景：视频电话（Video Telephony）  
- 通话一端的视频终端生成“编码码流”，发送给另一端的远程视频终端；  
- 编码码流在传输过程中可能损坏，导致远程终端解码时出现宏块错误；  
- 若应用程序可与两端终端通信，可在“解码终端”提取宏块错误映射，并发送给“编码终端”；  
- 编码终端可在后续编码帧中，用“帧内宏块（intra macroblocks）”刷新“错误宏块”。  

（原文图2-15：错误映射的典型应用场景）  
- 左侧：编码器（Encoder）接收“刷新请求（refresh request）”；  
- 中间：编码器→解码器（Decoder）传输数据，解码器向客户端（Client）发送“错误映射数据（error map data）”；  
- 右侧：客户端向编码器发送刷新请求。  

（原文页码：42）  


### 2.1.21 缓冲区有效数据补充信息（Buffer Payload Additional Information）  
根据“缓冲区有效数据类型”和“组件需求”，可能需要在“缓冲区末尾追加补充信息”，以便下一个组件进一步处理缓冲区有效数据。  

#### 示例：  
视频去块效应算法（video deblocking algorithms）需要“宏块级量化信息”才能对视频内容执行去块处理——此时需在缓冲区末尾追加该信息。  

#### 补充信息的标识：  
缓冲区头结构（`OMX_BUFFERHEADERTYPE`，详见3.1.2.7节）中的“额外数据（extra data）”缓冲区标志，用于标识“是否存在补充信息”。  

#### 补充信息的适用范围：  
补充信息仅适用于“缓冲区中的第一个新逻辑单元”。若缓冲区包含多个逻辑单元：  
- “额外数据”标志仅对“起始边界最先出现的逻辑单元”生效；  
- 后续逻辑单元无显式“额外数据”；  
- 若需为每个逻辑单元添加显式“额外数据”，则每个缓冲区应包含不超过一个逻辑单元。  


#### 2.1.21.1 缓冲区数据格式（Buffer Data Formatting）  
当存在额外数据时，“数据类型、大小”等属性由“对应的数据结构”标识——该数据结构紧接在“缓冲区有效数据”之后、“实际额外数据”之前。  

多个类型的额外数据可按以下方式追加到“常规有效数据”末尾：  
1. 以“块对（block pairs）”形式追加：每个块对包含“支持数据结构（supporting data structure）”和“实际数据（actual data）”；  
2. 在额外数据列表末尾，需添加一个“终止数据结构”，标识“额外数据列表结束”。  

更多细节详见4.2.33节。  

（原文图2-16：额外缓冲区数据的格式）  
- 缓冲区头（OMX_BUFFERHEADERTYPE）：`pBuffer`（缓冲区起始地址）、`nOffset=9`（有效数据偏移）、`nAllocLen=96`（缓冲区总分配长度）、`nFilledLen=21`（有效数据长度）、`nFlags=0x40`（含额外数据标志）；  
- 有效数据（data）：从`pBuffer + 9`开始，长度21字节；  
- 额外数据（extra data）：  
  1. 第一个块对：`OMX_OTHER_EXTRADATATYPE`结构（`nSize=28`、`nVersion`、`nPortIndex`、`eType=OMX_ExtraDataNone`、`nDataSize=6`）+ 6字节实际数据；  
  2. 终止块：`OMX_OTHER_EXTRADATATYPE`结构（`nSize=24`、`nVersion`、`nPortIndex`、`eType=OMX_ExtraDataNone`、`nDataSize=0`）；  
- 其他：偏移填充（offset paddling）、数据填充（data padding）、未使用区域（unused）。  

（原文页码：43）  


## 2.2 字节序（Endianness）  
OpenMAX IL API数据结构实现中使用的字节序，**必须遵循IL客户端运行平台的字节序**。该要求涵盖以下接口：  
1. IL客户端使用的接口；  
2. 组件间的接口（如两个隧道模式组件间专用的函数）。  

OpenMAX IL实现需负责“支持该要求所需的所有字节序转换”，且此类转换对以下对象透明：  
- IL客户端；  
- 与IL客户端使用相同字节序的组件。  

（原文页码：44）